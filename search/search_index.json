{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Pipeline Project \u2013 Climate Visualisation","text":"<p>This is a Houdini shelf tool that fetches climate data from the Copernicus API (EU satalite data platform) and visualises it directly within Houdini. It retrieves terrain elevation, optical satellite imagery, and temperature data, allowing users to explore environmental changes over time. The tool features a user-friendly UI where you can select dates, pick a region on a map, and generate dynamic 3D visualisations of terrain and temperature changes.</p>"},{"location":"#quick-start","title":"Quick Start","text":"<p>To explore the modules, use the navigation bar on the left.</p>"},{"location":"#how-it-works-summary","title":"How It Works (Summary)","text":"<ol> <li>User interacts with the UI inside Houdini</li> <li>The UI passes input to the Import Data</li> <li>Import Data:<ul> <li>Calls Utilities for map and folder setup</li> <li>Instantiates the appropriate Data Download classes to fetch Copernicus data</li> <li>Passes results to Node Setup classes to build visual networks in Houdini</li> </ul> </li> <li>Final result: Interactive visualisation inside Houdini based on the selected parameters</li> </ol>"},{"location":"#project-structure","title":"Project Structure","text":"<ul> <li> <p>UI   Folder containing Houdini shelf tool code and user interface logic. This is the entry point for:</p> <ul> <li>Selecting time ranges and frequency</li> <li>Choosing coordinates via an interactive map</li> <li>Triggering the full import and visualisation process</li> </ul> </li> <li> <p>Import Data   The central controller module that connects all components. It:</p> <ul> <li>Receives input from the UI</li> <li>Uses utility functions (e.g. for coordinate parsing)</li> <li>Instantiates and executes data import classes (e.g. <code>DEMFetcher</code>, <code>OpticalFetcher</code>, <code>ThermalFetcher</code>)</li> <li>Triggers Houdini node creation via the corresponding setup classes</li> </ul> </li> <li> <p>Data Download   Contains a base DataFetcher class and specialised child classes for each data type:</p> <ul> <li><code>terrain.py</code> - downloads elevation data</li> <li><code>optical.py</code> - downloads satellite imagery</li> <li><code>thermal.py</code> - downloads climate data</li> </ul> </li> <li> <p>Node Setup   Contains a base node setup class and child classes for generating Houdini node graphs:</p> <ul> <li><code>terrain_nodes.py</code> - builds heightfield terrain</li> <li><code>optical_nodes.py</code> - adds texture overlays</li> <li><code>temperature_nodes.py</code> - adds temperature sphere visualisation</li> <li>also contains noder helper functions</li> </ul> </li> <li> <p>Utilities   A set of general helper functions and tools, including:</p> <ul> <li>Authentification on Copernicus</li> <li>Area bounding box </li> <li>Date ranges</li> <li>Calculating dimensions based on the map coordinates</li> <li>Map interaction logic</li> </ul> </li> </ul>"},{"location":"UI/main/","title":"MainUI","text":""},{"location":"UI/main/#UI.main.UiWindow","title":"<code>UiWindow</code>","text":"<p>               Bases: <code>QDialog</code></p> <p>A class representing the main UI window for the application.</p> Source code in <code>src/UI/main.py</code> <pre><code>class UiWindow(QDialog):\n    \"\"\"\n    A class representing the main UI window for the application.\"\"\"\n    def __init__(self, parent=None):\n        \"\"\"\n        Initializes the UI window and sets up the basic components.\n        \"\"\"\n        super().__init__(parent)\n\n        self.ui = Ui_UiWindow()      \n        self.ui.setupUi(self)\n\n        self.setMinimumSize(350, 200)\n\n        # map ref\n        self.open_map = open_map\n        self.open_flask_server = open_flask_server\n\n        # #terrain ref\n        self.import_terrain = import_terrain\n        self.import_optical = import_optical\n        self.import_temperature = import_temperature\n        self.node_helpers = node_helpers\n        self.date_ranges = date_ranges\n\n        # connect buttons to functions\n        self.ui.open_map.clicked.connect(self.on_open_map_clicked)\n        self.ui.load_terrain.clicked.connect(self.on_terrain_clicked)\n        self.ui.pushButton_browse.clicked.connect(self.on_browse_clicked)\n        self.ui.load_thermal.clicked.connect(self.on_temperature_clicked)\n\n    def on_open_map_clicked(self):\n        \"\"\"\n        Starts the Flask server and opens the map in firefox where the user can then select the coordinates for the area.\"\"\"\n\n        data_folder = self.ui.lineEdit_browse.text().strip()\n        if not Path(data_folder).is_dir():\n            print(\"Please choose a valid data folder.\")\n            return\n        self.open_flask_server.start_new_server(data_folder)\n        self.open_map.open_map()\n\n    def handle_data_import(self, processor_func, needs_date_ranges=True):\n        \"\"\"\n        Handles the data import process by validating the input and calling the appropriate import functions for the different data types.\n        The user is either prompted to select a geo node or the cached geo node is used for temperature and optical data.\n        So only when new terrain data is imported, the user is prompted to select a geo node.\n\n        Args:\n            processor_func: The function to process the data import.\n            needs_date_ranges: Whether the function requires date ranges or not, since elevation data doesnt need a date range but optical and temperature do.\n        \"\"\"\n        data_folder = self.ui.lineEdit_browse.text().strip()\n        if not Path(data_folder).is_dir():\n            print(\"Please choose a valid data folder.\")\n            return\n\n        start_qdate = self.ui.start_date.date()\n        end_qdate = self.ui.end_date.date()\n        freq_text = self.ui.weekly_monthly.currentText() # \"weekly\" or \"monthly\"\n\n        if start_qdate &gt; end_qdate:\n            QMessageBox.critical(\n                self,\n                \"Invalid Date Range\",\n                \"Start date must be the same as or before the end date.\"\n            )\n            return\n\n        date_ranges = self.date_ranges.get_date_ranges(start_qdate, end_qdate, freq_text)\n\n        try:\n            geo = self.node_helpers.get_geo_node()\n            if needs_date_ranges:\n                processor_func(data_folder, geo, date_ranges)\n            else:\n                processor_func(data_folder, geo)\n\n            return data_folder, date_ranges\n\n        except hou.NodeError as e:\n            print(\"Operation cancelled by user:\", e)\n            return False\n\n        except Exception as e:\n            print(\"Error:\", e)\n            return False\n\n    def on_terrain_clicked(self):\n        \"\"\"\n        Handles the terrain data import by clearing the geo node cache, the prompting the user to select a geo node and then running the terrain and optical import functions.\n        \"\"\"\n        self.node_helpers.clear_geo_cache() # clear for each new process\n        success = self.handle_data_import(self.import_terrain.run_terrain, needs_date_ranges=False)\n        if not success:\n            return\n\n        success = self.handle_data_import(self.import_optical.run_optical, needs_date_ranges=True)\n        if not success:\n            return\n    def on_temperature_clicked(self):\n        \"\"\"\n        Handles the temperature data import by running the temperature import function.\n        \"\"\"\n        # dont clear cache here as its the same the geo node from the terrain import\n        success = self.handle_data_import(self.import_temperature.run_temperature, needs_date_ranges=True)\n        if not success:\n            return        \n\n    def on_browse_clicked(self):\n        \"\"\"\n        Opens a file dialog to select a folder and sets the selected folder path in the line edit.\"\"\"\n        folder = QFileDialog.getExistingDirectory(self, \"Select Folder\")\n\n        if folder:\n            self.ui.lineEdit_browse.setText(folder)\n</code></pre>"},{"location":"UI/main/#UI.main.UiWindow.__init__","title":"<code>__init__(parent=None)</code>","text":"<p>Initializes the UI window and sets up the basic components.</p> Source code in <code>src/UI/main.py</code> <pre><code>def __init__(self, parent=None):\n    \"\"\"\n    Initializes the UI window and sets up the basic components.\n    \"\"\"\n    super().__init__(parent)\n\n    self.ui = Ui_UiWindow()      \n    self.ui.setupUi(self)\n\n    self.setMinimumSize(350, 200)\n\n    # map ref\n    self.open_map = open_map\n    self.open_flask_server = open_flask_server\n\n    # #terrain ref\n    self.import_terrain = import_terrain\n    self.import_optical = import_optical\n    self.import_temperature = import_temperature\n    self.node_helpers = node_helpers\n    self.date_ranges = date_ranges\n\n    # connect buttons to functions\n    self.ui.open_map.clicked.connect(self.on_open_map_clicked)\n    self.ui.load_terrain.clicked.connect(self.on_terrain_clicked)\n    self.ui.pushButton_browse.clicked.connect(self.on_browse_clicked)\n    self.ui.load_thermal.clicked.connect(self.on_temperature_clicked)\n</code></pre>"},{"location":"UI/main/#UI.main.UiWindow.handle_data_import","title":"<code>handle_data_import(processor_func, needs_date_ranges=True)</code>","text":"<p>Handles the data import process by validating the input and calling the appropriate import functions for the different data types. The user is either prompted to select a geo node or the cached geo node is used for temperature and optical data. So only when new terrain data is imported, the user is prompted to select a geo node.</p> <p>Parameters:</p> Name Type Description Default <code>processor_func</code> <p>The function to process the data import.</p> required <code>needs_date_ranges</code> <p>Whether the function requires date ranges or not, since elevation data doesnt need a date range but optical and temperature do.</p> <code>True</code> Source code in <code>src/UI/main.py</code> <pre><code>def handle_data_import(self, processor_func, needs_date_ranges=True):\n    \"\"\"\n    Handles the data import process by validating the input and calling the appropriate import functions for the different data types.\n    The user is either prompted to select a geo node or the cached geo node is used for temperature and optical data.\n    So only when new terrain data is imported, the user is prompted to select a geo node.\n\n    Args:\n        processor_func: The function to process the data import.\n        needs_date_ranges: Whether the function requires date ranges or not, since elevation data doesnt need a date range but optical and temperature do.\n    \"\"\"\n    data_folder = self.ui.lineEdit_browse.text().strip()\n    if not Path(data_folder).is_dir():\n        print(\"Please choose a valid data folder.\")\n        return\n\n    start_qdate = self.ui.start_date.date()\n    end_qdate = self.ui.end_date.date()\n    freq_text = self.ui.weekly_monthly.currentText() # \"weekly\" or \"monthly\"\n\n    if start_qdate &gt; end_qdate:\n        QMessageBox.critical(\n            self,\n            \"Invalid Date Range\",\n            \"Start date must be the same as or before the end date.\"\n        )\n        return\n\n    date_ranges = self.date_ranges.get_date_ranges(start_qdate, end_qdate, freq_text)\n\n    try:\n        geo = self.node_helpers.get_geo_node()\n        if needs_date_ranges:\n            processor_func(data_folder, geo, date_ranges)\n        else:\n            processor_func(data_folder, geo)\n\n        return data_folder, date_ranges\n\n    except hou.NodeError as e:\n        print(\"Operation cancelled by user:\", e)\n        return False\n\n    except Exception as e:\n        print(\"Error:\", e)\n        return False\n</code></pre>"},{"location":"UI/main/#UI.main.UiWindow.on_browse_clicked","title":"<code>on_browse_clicked()</code>","text":"<p>Opens a file dialog to select a folder and sets the selected folder path in the line edit.</p> Source code in <code>src/UI/main.py</code> <pre><code>def on_browse_clicked(self):\n    \"\"\"\n    Opens a file dialog to select a folder and sets the selected folder path in the line edit.\"\"\"\n    folder = QFileDialog.getExistingDirectory(self, \"Select Folder\")\n\n    if folder:\n        self.ui.lineEdit_browse.setText(folder)\n</code></pre>"},{"location":"UI/main/#UI.main.UiWindow.on_open_map_clicked","title":"<code>on_open_map_clicked()</code>","text":"<p>Starts the Flask server and opens the map in firefox where the user can then select the coordinates for the area.</p> Source code in <code>src/UI/main.py</code> <pre><code>def on_open_map_clicked(self):\n    \"\"\"\n    Starts the Flask server and opens the map in firefox where the user can then select the coordinates for the area.\"\"\"\n\n    data_folder = self.ui.lineEdit_browse.text().strip()\n    if not Path(data_folder).is_dir():\n        print(\"Please choose a valid data folder.\")\n        return\n    self.open_flask_server.start_new_server(data_folder)\n    self.open_map.open_map()\n</code></pre>"},{"location":"UI/main/#UI.main.UiWindow.on_temperature_clicked","title":"<code>on_temperature_clicked()</code>","text":"<p>Handles the temperature data import by running the temperature import function.</p> Source code in <code>src/UI/main.py</code> <pre><code>def on_temperature_clicked(self):\n    \"\"\"\n    Handles the temperature data import by running the temperature import function.\n    \"\"\"\n    # dont clear cache here as its the same the geo node from the terrain import\n    success = self.handle_data_import(self.import_temperature.run_temperature, needs_date_ranges=True)\n    if not success:\n        return        \n</code></pre>"},{"location":"UI/main/#UI.main.UiWindow.on_terrain_clicked","title":"<code>on_terrain_clicked()</code>","text":"<p>Handles the terrain data import by clearing the geo node cache, the prompting the user to select a geo node and then running the terrain and optical import functions.</p> Source code in <code>src/UI/main.py</code> <pre><code>def on_terrain_clicked(self):\n    \"\"\"\n    Handles the terrain data import by clearing the geo node cache, the prompting the user to select a geo node and then running the terrain and optical import functions.\n    \"\"\"\n    self.node_helpers.clear_geo_cache() # clear for each new process\n    success = self.handle_data_import(self.import_terrain.run_terrain, needs_date_ranges=False)\n    if not success:\n        return\n\n    success = self.handle_data_import(self.import_optical.run_optical, needs_date_ranges=True)\n    if not success:\n        return\n</code></pre>"},{"location":"UI/main/#UI.main.run_ui","title":"<code>run_ui()</code>","text":"<p>Initializes and runs the UI window.</p> Source code in <code>src/UI/main.py</code> <pre><code>def run_ui():\n    \"\"\"\n    Initializes and runs the UI window.\"\"\"\n    window = UiWindow(parent=hou.ui.mainQtWindow())\n    window.show()\n</code></pre>"},{"location":"data_download/base/","title":"Base Class for Data Download from Copernicus","text":""},{"location":"data_download/base/#data_download.base.DataFetcher","title":"<code>DataFetcher</code>","text":"<p>Base class for any Copernicus data fetcher.</p> Source code in <code>src/data_download/base.py</code> <pre><code>class DataFetcher:\n    \"\"\"Base class for any Copernicus data fetcher.\"\"\"\n    PROCESS_URL = \"https://sh.dataspace.copernicus.eu/api/v1/process\"\n\n    def __init__(self, client_id, client_secret, coord_json_path, out_path):\n        \"\"\"\n        Initialize the data fetcher.\n\n        Args:\n            client_id (str): Copernicus client ID.\n            client_secret (str): Copernicus client secret.\n            coord_json_path (str): Path to the JSON file containing coordinates.\n            out_path (str): Path to save the output data.\n        \"\"\"\n        self.client_id     = client_id\n        self.client_secret = client_secret\n        self.coord_json    = coord_json_path\n        self.out_path      = out_path\n        self.bbox = None \n        self.load_bbox()\n\n\n    def authenticate(self):\n        \"\"\"Authenticate with the Copernicus API and fetch the token.\"\"\"\n        self.token = fetch_auth_token(self.client_id, self.client_secret)\n        if not self.token:\n            raise RuntimeError(\"Auth failed\")\n\n    def load_bbox(self):\n        \"\"\"Load the bounding box from the JSON file.\"\"\"\n        self.bbox = get_bbox_from_json(self.coord_json)\n        if not self.bbox:\n            raise RuntimeError(\"Invalid BBOX\")\n\n    def build_payload(self):\n        \"\"\"Build the payload for the API request.\"\"\"\n        raise NotImplementedError\n\n    def fetch(self):\n        \"\"\"\n        Fetch data from the Copernicus API.\n        This method handles the authentication, payload creation,\n        and the actual data fetching process.\n        \"\"\"\n        self.authenticate()\n        # self.load_bbox()\n        payload = self.build_payload()\n        headers = {\n          \"Authorization\": f\"Bearer {self.token}\",\n          \"Content-Type\":    \"application/json\",\n        }\n        # print(\"POSTING to\", self.PROCESS_URL)\n        # print(\"Payload:\", json.dumps(payload, indent=2))\n\n        resp = post_json(self.PROCESS_URL, headers, payload)\n\n        if resp is None:\n            print(\"Fetch failed, aborting or using fallback\")\n            return None\n\n        with open(self.out_path, \"wb\") as f:\n            f.write(resp.content)\n        return self.out_path\n</code></pre>"},{"location":"data_download/base/#data_download.base.DataFetcher.__init__","title":"<code>__init__(client_id, client_secret, coord_json_path, out_path)</code>","text":"<p>Initialize the data fetcher.</p> <p>Parameters:</p> Name Type Description Default <code>client_id</code> <code>str</code> <p>Copernicus client ID.</p> required <code>client_secret</code> <code>str</code> <p>Copernicus client secret.</p> required <code>coord_json_path</code> <code>str</code> <p>Path to the JSON file containing coordinates.</p> required <code>out_path</code> <code>str</code> <p>Path to save the output data.</p> required Source code in <code>src/data_download/base.py</code> <pre><code>def __init__(self, client_id, client_secret, coord_json_path, out_path):\n    \"\"\"\n    Initialize the data fetcher.\n\n    Args:\n        client_id (str): Copernicus client ID.\n        client_secret (str): Copernicus client secret.\n        coord_json_path (str): Path to the JSON file containing coordinates.\n        out_path (str): Path to save the output data.\n    \"\"\"\n    self.client_id     = client_id\n    self.client_secret = client_secret\n    self.coord_json    = coord_json_path\n    self.out_path      = out_path\n    self.bbox = None \n    self.load_bbox()\n</code></pre>"},{"location":"data_download/base/#data_download.base.DataFetcher.authenticate","title":"<code>authenticate()</code>","text":"<p>Authenticate with the Copernicus API and fetch the token.</p> Source code in <code>src/data_download/base.py</code> <pre><code>def authenticate(self):\n    \"\"\"Authenticate with the Copernicus API and fetch the token.\"\"\"\n    self.token = fetch_auth_token(self.client_id, self.client_secret)\n    if not self.token:\n        raise RuntimeError(\"Auth failed\")\n</code></pre>"},{"location":"data_download/base/#data_download.base.DataFetcher.build_payload","title":"<code>build_payload()</code>","text":"<p>Build the payload for the API request.</p> Source code in <code>src/data_download/base.py</code> <pre><code>def build_payload(self):\n    \"\"\"Build the payload for the API request.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"data_download/base/#data_download.base.DataFetcher.fetch","title":"<code>fetch()</code>","text":"<p>Fetch data from the Copernicus API. This method handles the authentication, payload creation, and the actual data fetching process.</p> Source code in <code>src/data_download/base.py</code> <pre><code>def fetch(self):\n    \"\"\"\n    Fetch data from the Copernicus API.\n    This method handles the authentication, payload creation,\n    and the actual data fetching process.\n    \"\"\"\n    self.authenticate()\n    # self.load_bbox()\n    payload = self.build_payload()\n    headers = {\n      \"Authorization\": f\"Bearer {self.token}\",\n      \"Content-Type\":    \"application/json\",\n    }\n    # print(\"POSTING to\", self.PROCESS_URL)\n    # print(\"Payload:\", json.dumps(payload, indent=2))\n\n    resp = post_json(self.PROCESS_URL, headers, payload)\n\n    if resp is None:\n        print(\"Fetch failed, aborting or using fallback\")\n        return None\n\n    with open(self.out_path, \"wb\") as f:\n        f.write(resp.content)\n    return self.out_path\n</code></pre>"},{"location":"data_download/base/#data_download.base.DataFetcher.load_bbox","title":"<code>load_bbox()</code>","text":"<p>Load the bounding box from the JSON file.</p> Source code in <code>src/data_download/base.py</code> <pre><code>def load_bbox(self):\n    \"\"\"Load the bounding box from the JSON file.\"\"\"\n    self.bbox = get_bbox_from_json(self.coord_json)\n    if not self.bbox:\n        raise RuntimeError(\"Invalid BBOX\")\n</code></pre>"},{"location":"data_download/optical/","title":"Optical Data Download","text":""},{"location":"data_download/optical/#data_download.optical.OpticalFetcher","title":"<code>OpticalFetcher</code>","text":"<p>               Bases: <code>DataFetcher</code></p> <p>Class to fetch optical data from Copernicus API.</p> Source code in <code>src/data_download/optical.py</code> <pre><code>class OpticalFetcher(DataFetcher):\n    \"\"\"Class to fetch optical data from Copernicus API.\"\"\"\n    def __init__(self, client_id, client_secret, coord_json,\n                 out_png, width, height, time_from, time_to):\n        \"\"\"\n        Initialize the OpticalFetcher.\n\n        Args:\n            client_id (str): Copernicus client ID.\n            client_secret (str): Copernicus client secret.\n            coord_json (str): Path to the JSON file containing coordinates.\n            out_png (str): Path to save the output PNG.\n            width (int): Width of the output image.\n            height (int): Height of the output image.\n            time_from (str): Start time for data fetching.\n            time_to (str): End time for data fetching.\n        \"\"\"\n        super().__init__(client_id, client_secret, coord_json, out_png)\n        self.width, self.height = width, height\n        self.time_from, self.time_to = time_from, time_to\n\n    def build_payload(self):\n        \"\"\"Build the payload for the API request, specifically for the optical data.\"\"\"\n        return {\n          \"input\": {\n            \"bounds\": {\"properties\":{\"crs\":\"http://www.opengis.net/def/crs/OGC/1.3/CRS84\"},\"bbox\":self.bbox},\n            \"data\": [{\n              \"type\":\"sentinel-2-l2a\",\n              \"dataFilter\": {\n                 \"timeRange\": {\"from\":self.time_from, \"to\":self.time_to},\n                 \"orbitDirection\": \"DESCENDING\"\n              }\n            }]\n          },\n          \"output\": {\"width\":self.width,\"height\":self.height},\n\n          \"evalscript\": \"\"\"\n            //VERSION=3\n            function setup() {\n            return {\n                input: [\"B02\", \"B03\", \"B04\"],\n                output: { bands: 3 },\n            }\n            }\n\n            function evaluatePixel(sample) {\n            return [2.5 * sample.B04, 2.5 * sample.B03, 2.5 * sample.B02]\n            }\n            \"\"\"\n        }\n\n    def fetch(self):\n        \"\"\"Override fetch to modify headers to accept tiff format.\"\"\"\n        self.authenticate()\n        self.load_bbox()\n        payload = self.build_payload()\n        headers = {\n            \"Authorization\": f\"Bearer {self.token}\",\n            \"Content-Type\": \"application/json\",\n            \"Accept\": \"image/tiff\", \n        }\n\n        resp = post_json(self.PROCESS_URL, headers, payload)\n\n        if resp is None:\n            print(\"Fetch failed, aborting or using fallback\")\n            return None\n\n        with open(self.out_path, \"wb\") as f:\n            f.write(resp.content)\n        return self.out_path\n</code></pre>"},{"location":"data_download/optical/#data_download.optical.OpticalFetcher.__init__","title":"<code>__init__(client_id, client_secret, coord_json, out_png, width, height, time_from, time_to)</code>","text":"<p>Initialize the OpticalFetcher.</p> <p>Parameters:</p> Name Type Description Default <code>client_id</code> <code>str</code> <p>Copernicus client ID.</p> required <code>client_secret</code> <code>str</code> <p>Copernicus client secret.</p> required <code>coord_json</code> <code>str</code> <p>Path to the JSON file containing coordinates.</p> required <code>out_png</code> <code>str</code> <p>Path to save the output PNG.</p> required <code>width</code> <code>int</code> <p>Width of the output image.</p> required <code>height</code> <code>int</code> <p>Height of the output image.</p> required <code>time_from</code> <code>str</code> <p>Start time for data fetching.</p> required <code>time_to</code> <code>str</code> <p>End time for data fetching.</p> required Source code in <code>src/data_download/optical.py</code> <pre><code>def __init__(self, client_id, client_secret, coord_json,\n             out_png, width, height, time_from, time_to):\n    \"\"\"\n    Initialize the OpticalFetcher.\n\n    Args:\n        client_id (str): Copernicus client ID.\n        client_secret (str): Copernicus client secret.\n        coord_json (str): Path to the JSON file containing coordinates.\n        out_png (str): Path to save the output PNG.\n        width (int): Width of the output image.\n        height (int): Height of the output image.\n        time_from (str): Start time for data fetching.\n        time_to (str): End time for data fetching.\n    \"\"\"\n    super().__init__(client_id, client_secret, coord_json, out_png)\n    self.width, self.height = width, height\n    self.time_from, self.time_to = time_from, time_to\n</code></pre>"},{"location":"data_download/optical/#data_download.optical.OpticalFetcher.build_payload","title":"<code>build_payload()</code>","text":"<p>Build the payload for the API request, specifically for the optical data.</p> Source code in <code>src/data_download/optical.py</code> <pre><code>def build_payload(self):\n    \"\"\"Build the payload for the API request, specifically for the optical data.\"\"\"\n    return {\n      \"input\": {\n        \"bounds\": {\"properties\":{\"crs\":\"http://www.opengis.net/def/crs/OGC/1.3/CRS84\"},\"bbox\":self.bbox},\n        \"data\": [{\n          \"type\":\"sentinel-2-l2a\",\n          \"dataFilter\": {\n             \"timeRange\": {\"from\":self.time_from, \"to\":self.time_to},\n             \"orbitDirection\": \"DESCENDING\"\n          }\n        }]\n      },\n      \"output\": {\"width\":self.width,\"height\":self.height},\n\n      \"evalscript\": \"\"\"\n        //VERSION=3\n        function setup() {\n        return {\n            input: [\"B02\", \"B03\", \"B04\"],\n            output: { bands: 3 },\n        }\n        }\n\n        function evaluatePixel(sample) {\n        return [2.5 * sample.B04, 2.5 * sample.B03, 2.5 * sample.B02]\n        }\n        \"\"\"\n    }\n</code></pre>"},{"location":"data_download/optical/#data_download.optical.OpticalFetcher.fetch","title":"<code>fetch()</code>","text":"<p>Override fetch to modify headers to accept tiff format.</p> Source code in <code>src/data_download/optical.py</code> <pre><code>def fetch(self):\n    \"\"\"Override fetch to modify headers to accept tiff format.\"\"\"\n    self.authenticate()\n    self.load_bbox()\n    payload = self.build_payload()\n    headers = {\n        \"Authorization\": f\"Bearer {self.token}\",\n        \"Content-Type\": \"application/json\",\n        \"Accept\": \"image/tiff\", \n    }\n\n    resp = post_json(self.PROCESS_URL, headers, payload)\n\n    if resp is None:\n        print(\"Fetch failed, aborting or using fallback\")\n        return None\n\n    with open(self.out_path, \"wb\") as f:\n        f.write(resp.content)\n    return self.out_path\n</code></pre>"},{"location":"data_download/terrain/","title":"Terrain Data Download","text":""},{"location":"data_download/terrain/#data_download.terrain.DEMFetcher","title":"<code>DEMFetcher</code>","text":"<p>               Bases: <code>DataFetcher</code></p> <p>Class to fetch Digital Elevation Model (DEM) data from Copernicus API.</p> Source code in <code>src/data_download/terrain.py</code> <pre><code>class DEMFetcher(DataFetcher):\n    \"\"\"Class to fetch Digital Elevation Model (DEM) data from Copernicus API.\"\"\"\n    def __init__(self, client_id, client_secret, coord_json, out_tiff, res=0.0003):\n        \"\"\"\n        Initialize the DEMFetcher.\n\n        Args:\n            client_id (str): Copernicus client ID.\n            client_secret (str): Copernicus client secret.\n            coord_json (str): Path to the JSON file containing coordinates.\n            out_tiff (str): Path to save the output TIFF.\n            res (float): Resolution of the output data.\n        \"\"\"\n        super().__init__(client_id, client_secret, coord_json, out_tiff)\n        self.res = res\n\n    def build_payload(self):\n        \"\"\"Build the payload for the API request, specifically for the DEM data.\"\"\"\n        return {\n          \"input\": {\n            \"bounds\": {\n              \"properties\": {\"crs\": \"http://www.opengis.net/def/crs/OGC/1.3/CRS84\"},\n              \"bbox\": self.bbox\n            },\n            \"data\": [\n              {\n                \"type\": \"dem\",\n                \"dataFilter\": {\"demInstance\": \"COPERNICUS_30\"},\n                \"processing\": {\"upsampling\": \"BILINEAR\", \"downsampling\": \"BILINEAR\"}\n              }\n            ]\n          },\n          \"output\": {\n            \"resx\": self.res, \"resy\": self.res,\n            \"responses\": [{\"identifier\":\"default\",\"format\":{\"type\":\"image/tiff\"}}]\n          },\n          \"evalscript\": \"\"\"\n            //VERSION=3\n            function setup() {\n            return {\n                input: [\"DEM\"],\n                output: { bands: 1 },\n            }\n            }\n\n            function evaluatePixel(sample) {\n            return [sample.DEM / 2200]\n            }\n            \"\"\"\n        }\n</code></pre>"},{"location":"data_download/terrain/#data_download.terrain.DEMFetcher.__init__","title":"<code>__init__(client_id, client_secret, coord_json, out_tiff, res=0.0003)</code>","text":"<p>Initialize the DEMFetcher.</p> <p>Parameters:</p> Name Type Description Default <code>client_id</code> <code>str</code> <p>Copernicus client ID.</p> required <code>client_secret</code> <code>str</code> <p>Copernicus client secret.</p> required <code>coord_json</code> <code>str</code> <p>Path to the JSON file containing coordinates.</p> required <code>out_tiff</code> <code>str</code> <p>Path to save the output TIFF.</p> required <code>res</code> <code>float</code> <p>Resolution of the output data.</p> <code>0.0003</code> Source code in <code>src/data_download/terrain.py</code> <pre><code>def __init__(self, client_id, client_secret, coord_json, out_tiff, res=0.0003):\n    \"\"\"\n    Initialize the DEMFetcher.\n\n    Args:\n        client_id (str): Copernicus client ID.\n        client_secret (str): Copernicus client secret.\n        coord_json (str): Path to the JSON file containing coordinates.\n        out_tiff (str): Path to save the output TIFF.\n        res (float): Resolution of the output data.\n    \"\"\"\n    super().__init__(client_id, client_secret, coord_json, out_tiff)\n    self.res = res\n</code></pre>"},{"location":"data_download/terrain/#data_download.terrain.DEMFetcher.build_payload","title":"<code>build_payload()</code>","text":"<p>Build the payload for the API request, specifically for the DEM data.</p> Source code in <code>src/data_download/terrain.py</code> <pre><code>def build_payload(self):\n    \"\"\"Build the payload for the API request, specifically for the DEM data.\"\"\"\n    return {\n      \"input\": {\n        \"bounds\": {\n          \"properties\": {\"crs\": \"http://www.opengis.net/def/crs/OGC/1.3/CRS84\"},\n          \"bbox\": self.bbox\n        },\n        \"data\": [\n          {\n            \"type\": \"dem\",\n            \"dataFilter\": {\"demInstance\": \"COPERNICUS_30\"},\n            \"processing\": {\"upsampling\": \"BILINEAR\", \"downsampling\": \"BILINEAR\"}\n          }\n        ]\n      },\n      \"output\": {\n        \"resx\": self.res, \"resy\": self.res,\n        \"responses\": [{\"identifier\":\"default\",\"format\":{\"type\":\"image/tiff\"}}]\n      },\n      \"evalscript\": \"\"\"\n        //VERSION=3\n        function setup() {\n        return {\n            input: [\"DEM\"],\n            output: { bands: 1 },\n        }\n        }\n\n        function evaluatePixel(sample) {\n        return [sample.DEM / 2200]\n        }\n        \"\"\"\n    }\n</code></pre>"},{"location":"data_download/thermal/","title":"Temperature Data Download","text":""},{"location":"data_download/thermal/#data_download.thermal.ThermalFetcher","title":"<code>ThermalFetcher</code>","text":"<p>               Bases: <code>DataFetcher</code></p> <p>Class to fetch thermal data from Copernicus API.</p> Source code in <code>src/data_download/thermal.py</code> <pre><code>class ThermalFetcher(DataFetcher):\n    \"\"\"Class to fetch thermal data from Copernicus API.\"\"\"\n    def __init__(self, client_id, client_secret, coord_json,\n                 out_png, width, height, time_from, time_to):\n        \"\"\"\n        Initialize the ThermalFetcher.\n\n        Args:\n            client_id (str): Copernicus client ID.\n            client_secret (str): Copernicus client secret.\n            coord_json (str): Path to the JSON file containing coordinates.\n            out_png (str): Path to save the output PNG.\n            width (int): Width of the output image.\n            height (int): Height of the output image.\n            time_from (str): Start time for data fetching.\n            time_to (str): End time for data fetching.\n        \"\"\"\n        super().__init__(client_id, client_secret, coord_json, out_png)\n        self.width, self.height = width, height\n        self.time_from, self.time_to = time_from, time_to\n\n    def build_payload(self):\n        \"\"\"Build the payload for the API request, specifically for the thermal data.\"\"\"\n        return {\n          \"input\": {\n            \"bounds\": {\"properties\":{\"crs\":\"http://www.opengis.net/def/crs/EPSG/0/4326\"},\"bbox\":self.bbox},\n            \"data\": [{\n              \"type\":\"sentinel-3-slstr\",\n              \"dataFilter\": {\n                 \"timeRange\": {\"from\":self.time_from, \"to\":self.time_to},\n                 \"orbitDirection\": \"DESCENDING\"\n              }\n            }]\n          },\n          \"output\": {\"width\":self.width,\"height\":self.height,\n                     \"responses\":[{\"format\":{\"type\":\"image/png\"}}]},\n\n          \"evalscript\": \"\"\"\n            //VERSION=3\n            function setup() {\n            return {\n                input: [\"F1\"],\n                output: {\n                bands: 3,\n                },\n            }\n            }\n\n            // Create a Red gradient visualiser from 274-450 K\n            var viz = ColorGradientVisualizer.createRedTemperature(274, 450)\n\n            function evaluatePixel(sample) {\n            return viz.process(sample.F1)\n            }\n            \"\"\"\n        }\n</code></pre>"},{"location":"data_download/thermal/#data_download.thermal.ThermalFetcher.__init__","title":"<code>__init__(client_id, client_secret, coord_json, out_png, width, height, time_from, time_to)</code>","text":"<p>Initialize the ThermalFetcher.</p> <p>Parameters:</p> Name Type Description Default <code>client_id</code> <code>str</code> <p>Copernicus client ID.</p> required <code>client_secret</code> <code>str</code> <p>Copernicus client secret.</p> required <code>coord_json</code> <code>str</code> <p>Path to the JSON file containing coordinates.</p> required <code>out_png</code> <code>str</code> <p>Path to save the output PNG.</p> required <code>width</code> <code>int</code> <p>Width of the output image.</p> required <code>height</code> <code>int</code> <p>Height of the output image.</p> required <code>time_from</code> <code>str</code> <p>Start time for data fetching.</p> required <code>time_to</code> <code>str</code> <p>End time for data fetching.</p> required Source code in <code>src/data_download/thermal.py</code> <pre><code>def __init__(self, client_id, client_secret, coord_json,\n             out_png, width, height, time_from, time_to):\n    \"\"\"\n    Initialize the ThermalFetcher.\n\n    Args:\n        client_id (str): Copernicus client ID.\n        client_secret (str): Copernicus client secret.\n        coord_json (str): Path to the JSON file containing coordinates.\n        out_png (str): Path to save the output PNG.\n        width (int): Width of the output image.\n        height (int): Height of the output image.\n        time_from (str): Start time for data fetching.\n        time_to (str): End time for data fetching.\n    \"\"\"\n    super().__init__(client_id, client_secret, coord_json, out_png)\n    self.width, self.height = width, height\n    self.time_from, self.time_to = time_from, time_to\n</code></pre>"},{"location":"data_download/thermal/#data_download.thermal.ThermalFetcher.build_payload","title":"<code>build_payload()</code>","text":"<p>Build the payload for the API request, specifically for the thermal data.</p> Source code in <code>src/data_download/thermal.py</code> <pre><code>def build_payload(self):\n    \"\"\"Build the payload for the API request, specifically for the thermal data.\"\"\"\n    return {\n      \"input\": {\n        \"bounds\": {\"properties\":{\"crs\":\"http://www.opengis.net/def/crs/EPSG/0/4326\"},\"bbox\":self.bbox},\n        \"data\": [{\n          \"type\":\"sentinel-3-slstr\",\n          \"dataFilter\": {\n             \"timeRange\": {\"from\":self.time_from, \"to\":self.time_to},\n             \"orbitDirection\": \"DESCENDING\"\n          }\n        }]\n      },\n      \"output\": {\"width\":self.width,\"height\":self.height,\n                 \"responses\":[{\"format\":{\"type\":\"image/png\"}}]},\n\n      \"evalscript\": \"\"\"\n        //VERSION=3\n        function setup() {\n        return {\n            input: [\"F1\"],\n            output: {\n            bands: 3,\n            },\n        }\n        }\n\n        // Create a Red gradient visualiser from 274-450 K\n        var viz = ColorGradientVisualizer.createRedTemperature(274, 450)\n\n        function evaluatePixel(sample) {\n        return viz.process(sample.F1)\n        }\n        \"\"\"\n    }\n</code></pre>"},{"location":"import_data/import_optical/","title":"Optical Data Import","text":""},{"location":"import_data/import_optical/#import_data.import_optical.run_optical","title":"<code>run_optical(data_folder, geo=None, date_ranges=None)</code>","text":"<p>Runs the optical import using the provided data_folder from the UI.</p> <p>Parameters:</p> Name Type Description Default <code>data_folder</code> <code>str</code> <p>The folder where the optical data is stored.</p> required <code>geo</code> <code>Geometry</code> <p>The geometry node to use.</p> <code>None</code> <code>date_ranges</code> <code>list of tuples</code> <p>List of tuples containing start and end dates for fetching data.</p> <code>None</code> Creates <ul> <li>Optical data files in the user-specified data folder.</li> <li>Optical nodes in Houdini.</li> </ul> Source code in <code>src/import_data/import_optical.py</code> <pre><code>def run_optical(data_folder, geo=None, date_ranges=None):\n    \"\"\"\n    Runs the optical import using the provided data_folder from the UI.\n\n    Args:\n        data_folder (str): The folder where the optical data is stored.\n        geo (hou.Geometry): The geometry node to use.\n        date_ranges (list of tuples): List of tuples containing start and end dates for fetching data.\n\n    Creates:\n        - Optical data files in the user-specified data folder.\n        - Optical nodes in Houdini.\n    \"\"\"\n    if geo is None:\n        geo = get_geo_node()\n\n    if not Path(data_folder).is_dir():\n        raise ValueError(f\"Invalid data folder: {data_folder}\")\n\n    file_path = Path(data_folder) / \"optical_data.tiff\"\n    json_file_path = Path(data_folder) / \"coords.json\"\n\n    delete_existing_images(data_folder, \"optical_data\", \"tiff\")\n    bbox = get_bbox_from_json(json_file_path)\n    dimensions = get_image_dimensions(json_file_path)\n    width, height = dimensions\n\n    if date_ranges is None:\n        date_ranges = [\n            (\"2018-08-01T00:00:00Z\", \"2018-08-07T23:59:59Z\"),\n            (\"2018-08-08T00:00:00Z\", \"2018-08-14T23:59:59Z\"),\n            (\"2018-08-15T00:00:00Z\", \"2018-08-21T23:59:59Z\"),\n            (\"2018-08-22T00:00:00Z\", \"2018-08-28T23:59:59Z\"),\n        ]\n\n    if len(date_ranges) &gt; 10:\n        choice = hou.ui.displayMessage(\n            f\"You are about to fetch {len(date_ranges)} images. This might be too many.\\n\"\n            \"Do you want to continue?\",\n            buttons=('Continue', 'Cancel')\n        )\n        if choice == 1:  # Cancel\n            raise hou.Error(\"Fetching process cancelled by user due to too many images.\")\n\n    try:\n        for idx, (time_from, time_to) in enumerate(date_ranges, start=1):\n\n            file_path = Path(data_folder) / f\"optical_data_{idx}.tiff\"\n            fetcher = OpticalFetcher(CLIENT_ID, CLIENT_SECRET, str(json_file_path), str(file_path), width, height, time_from, time_to)\n            result = fetcher.fetch()\n\n            if result:\n                print(f\"Successfully fetched optical data {idx}!\")\n\n            else:\n                print(f\"Failed to fetch optical data {idx}. Stopping the process.\")\n                break\n    except hou.Error as e:\n        print(f\"Error: {e}\")\n    except KeyboardInterrupt:\n        print(\"\\nOperation cancelled by user.\")\n\n    optical_builder = OpticalNodeBuilder(geo, data_folder, date_ranges)\n    optical_node = optical_builder.build()\n</code></pre>"},{"location":"import_data/import_temperature/","title":"Temperature Data Import","text":""},{"location":"import_data/import_temperature/#import_data.import_temperature.run_temperature","title":"<code>run_temperature(data_folder, geo=None, date_ranges=None)</code>","text":"<p>Runs the temperature import logic using the provided data_folder.</p> <p>Parameters:</p> Name Type Description Default <code>data_folder</code> <code>str</code> <p>The folder where the optical data is stored.</p> required <code>geo</code> <code>Geometry</code> <p>The geometry node to use.</p> <code>None</code> <code>date_ranges</code> <code>list of tuples</code> <p>List of tuples containing start and end dates for fetching data.</p> <code>None</code> Creates <ul> <li>Thermal data files in the user-specified data folder.</li> <li>Temperature nodes in Houdini.</li> </ul> Source code in <code>src/import_data/import_temperature.py</code> <pre><code>def run_temperature(data_folder, geo=None, date_ranges=None):\n    \"\"\"\n    Runs the temperature import logic using the provided data_folder.\n\n    Args:\n        data_folder (str): The folder where the optical data is stored.\n        geo (hou.Geometry): The geometry node to use.\n        date_ranges (list of tuples): List of tuples containing start and end dates for fetching data.\n\n    Creates:\n        - Thermal data files in the user-specified data folder.\n        - Temperature nodes in Houdini.\n    \"\"\"\n    if geo is None:\n        geo = get_geo_node()\n\n    if not Path(data_folder).is_dir():\n        raise ValueError(f\"Invalid data folder: {data_folder}\")\n\n    file_path = Path(data_folder) / \"thermal_data.png\"\n    json_file_path = Path(data_folder) / \"coords.json\"\n\n    delete_existing_images(data_folder, \"thermal_data\", \"png\")\n\n    bbox = get_bbox_from_json(json_file_path)\n    dimensions = get_image_dimensions(json_file_path)\n    width, height = dimensions\n\n    if date_ranges is None:\n        date_ranges = [\n            (\"2018-08-01T00:00:00Z\", \"2018-08-07T23:59:59Z\"),\n            (\"2018-08-08T00:00:00Z\", \"2018-08-14T23:59:59Z\"),\n            (\"2018-08-15T00:00:00Z\", \"2018-08-21T23:59:59Z\"),\n            (\"2018-08-22T00:00:00Z\", \"2018-08-28T23:59:59Z\"),\n        ]\n\n    if len(date_ranges) &gt; 10:\n        choice = hou.ui.displayMessage(\n            f\"You are about to fetch {len(date_ranges)} images. This might be too many.\\n\"\n            \"Do you want to continue?\",\n            buttons=('Continue', 'Cancel')\n        )\n        if choice == 1:  # Cancel\n            raise hou.Error(\"Fetching process cancelled by user due to too many images.\")\n\n    try: \n        for idx, (time_from, time_to) in enumerate(date_ranges, start=1):\n            file_path = Path(data_folder) / f\"thermal_data_{idx}.png\"\n            #print(f\"Fetching image {idx} from {time_from} to {time_to}\")\n            fetcher = ThermalFetcher(CLIENT_ID, CLIENT_SECRET, json_file_path, file_path, width, height, time_from, time_to)\n            result = fetcher.fetch()\n\n            if result:\n                print(f\"Successfully fetched thermal data {idx}!\")\n\n            else:\n                print(f\"Failed to fetch thermal data {idx}. Stopping the process.\")\n                break\n\n    except hou.Error as e:\n        print(f\"Error: {e}\")\n    except KeyboardInterrupt:\n        print(\"\\nOperation cancelled by user.\")\n\n    thermal_builder = TemperatureNodeBuilder(geo, data_folder, date_ranges)\n    thermal_node = thermal_builder.build()\n</code></pre>"},{"location":"import_data/import_terrain/","title":"Terrain Data Import","text":""},{"location":"import_data/import_terrain/#import_data.import_terrain.run_terrain","title":"<code>run_terrain(data_folder, geo=None)</code>","text":"<p>Runs the terrain import logic using the provided data_folder.</p> <p>Parameters:</p> Name Type Description Default <code>data_folder</code> <code>str</code> <p>The folder where the terrain data is stored.</p> required <code>geo</code> <code>Geometry</code> <p>The geometry node to use.</p> <code>None</code> Creates <ul> <li>A DEM data file in the user-specified data folder.</li> <li>Terrain nodes or fallback nodes in Houdini.</li> </ul> Source code in <code>src/import_data/import_terrain.py</code> <pre><code>def run_terrain(data_folder, geo=None):\n    \"\"\"\n    Runs the terrain import logic using the provided data_folder.\n\n    Args:\n        data_folder (str): The folder where the terrain data is stored.\n        geo (hou.Geometry): The geometry node to use.\n\n    Creates:\n        - A DEM data file in the user-specified data folder.\n        - Terrain nodes or fallback nodes in Houdini.\n    \"\"\"\n    if geo is None:\n        geo = get_geo_node()\n    if not Path(data_folder).is_dir():\n        raise ValueError(f\"Invalid data folder: {data_folder}\")\n\n    file_path = Path(data_folder) / \"dem_data.tiff\"\n    json_file_path = Path(data_folder) / \"coords.json\"\n\n    # print(f\"Reading from: {json_file_path}\")\n    # print(f\"Writing to: {file_path}\")\n\n    #geo = get_geo_node()\n\n    fetcher = DEMFetcher(CLIENT_ID, CLIENT_SECRET, str(json_file_path), str(file_path))\n    result = fetcher.fetch()\n\n    bbox = get_bbox_from_json(json_file_path)\n\n    if result:\n        DEMNodeBuilder(geo, str(file_path), str(json_file_path)).build()\n\n    else:\n        print(\"Failed to fetch DEM data. Creating tiff image based on coordinates instead.\")\n        fallback_path = Path(data_folder) / \"fallback.tiff\"\n        dimensions = get_image_dimensions(json_file_path)\n        if not dimensions:\n            print(\"Failed to get image dimensions.\")\n            return\n        width, height = dimensions\n        FallbackNodeBuilder(geo, str(fallback_path), width, height).build()\n</code></pre>"},{"location":"node_setup/node_builder/","title":"Base Node Builder Class","text":""},{"location":"node_setup/node_builder/#node_setup.node_builder.NodeBuilder","title":"<code>NodeBuilder</code>","text":"<p>Base class for building a node graph in Houdini. Subclasses should implement the build() method to create a specific node graph.</p> Source code in <code>src/node_setup/node_builder.py</code> <pre><code>class NodeBuilder:\n    \"\"\"\n    Base class for building a node graph in Houdini.\n    Subclasses should implement the build() method to create a specific node graph.\n    \"\"\"\n    def __init__(self, geo_node):\n        \"\"\"\n        Initializes the NodeBuilder with a geometry node.\n\n        Args:\n            geo_node (hou.Node): The geometry node to build the node graph in.\n        \"\"\"\n        self.geo = geo_node\n        if not self.geo:\n            raise hou.NodeError(\"Geometry node is None\")\n\n    def build(self):\n        \"\"\"Subclasses implement their node graph here.\"\"\"\n        raise NotImplementedError\n\n    def layout(self):\n        \"\"\"\n        Layout the children nodes.\n        \"\"\"\n        self.geo.layoutChildren()\n</code></pre>"},{"location":"node_setup/node_builder/#node_setup.node_builder.NodeBuilder.__init__","title":"<code>__init__(geo_node)</code>","text":"<p>Initializes the NodeBuilder with a geometry node.</p> <p>Parameters:</p> Name Type Description Default <code>geo_node</code> <code>Node</code> <p>The geometry node to build the node graph in.</p> required Source code in <code>src/node_setup/node_builder.py</code> <pre><code>def __init__(self, geo_node):\n    \"\"\"\n    Initializes the NodeBuilder with a geometry node.\n\n    Args:\n        geo_node (hou.Node): The geometry node to build the node graph in.\n    \"\"\"\n    self.geo = geo_node\n    if not self.geo:\n        raise hou.NodeError(\"Geometry node is None\")\n</code></pre>"},{"location":"node_setup/node_builder/#node_setup.node_builder.NodeBuilder.build","title":"<code>build()</code>","text":"<p>Subclasses implement their node graph here.</p> Source code in <code>src/node_setup/node_builder.py</code> <pre><code>def build(self):\n    \"\"\"Subclasses implement their node graph here.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"node_setup/node_builder/#node_setup.node_builder.NodeBuilder.layout","title":"<code>layout()</code>","text":"<p>Layout the children nodes.</p> Source code in <code>src/node_setup/node_builder.py</code> <pre><code>def layout(self):\n    \"\"\"\n    Layout the children nodes.\n    \"\"\"\n    self.geo.layoutChildren()\n</code></pre>"},{"location":"node_setup/node_helpers/","title":"Node Setup Helper Functions","text":""},{"location":"node_setup/node_helpers/#node_setup.node_helpers.build_wrangle_snippet","title":"<code>build_wrangle_snippet(data_folder, num_images, data_type, data_format)</code>","text":"<p>Builds a wrangle snippet for blending images using colormap. The snippet uses the UV coordinates of the current point to sample the images. The blending is controlled by a slider that allows the user to blend between different times, for example for weekly data of 4 weeks it would set up a slider from 0 to 4. The snippet is designed to be used in a Wrangle node in Houdini.</p> <p>Parameters:</p> Name Type Description Default <code>data_folder</code> <code>str</code> <p>Path to the folder containing the images.</p> required <code>num_images</code> <code>int</code> <p>Number of images to blend.</p> required <code>data_type</code> <code>str</code> <p>Type of data, so either temperature or optical satalite data.</p> required <code>data_format</code> <code>str</code> <p>Format of the images (\"png\", \"jpg\").</p> required <p>Returns:</p> Name Type Description <code>snippet</code> <code>str</code> <p>The generated wrangle snippet.</p> Source code in <code>src/node_setup/node_helpers.py</code> <pre><code>def build_wrangle_snippet(data_folder, num_images, data_type, data_format):\n    \"\"\"\n    Builds a wrangle snippet for blending images using colormap.\n    The snippet uses the UV coordinates of the current point to sample the images.\n    The blending is controlled by a slider that allows the user to blend between different times, for example for weekly data of 4 weeks it would set up a slider from 0 to 4.\n    The snippet is designed to be used in a Wrangle node in Houdini.\n\n    Args:\n        data_folder (str): Path to the folder containing the images.\n        num_images (int): Number of images to blend.\n        data_type (str): Type of data, so either temperature or optical satalite data.\n        data_format (str): Format of the images (\"png\", \"jpg\").\n\n    Returns:\n        snippet (str): The generated wrangle snippet.\n    \"\"\"\n    lines = ['vector uv = point(0, \"uv\", @ptnum);', '']\n\n    # Load colormaps\n    for i in range(1, num_images + 1):\n        img = Path(data_folder) / f\"{data_type}_{i}.{data_format}\"\n        lines.append(f'vector map{i} = colormap(\"{img}\", uv);')\n    lines.append('')\n\n    # Blending logic\n    lines.append(f'float blend = chf(\"blendAll\"); // 0\u2013{num_images - 1}')\n    lines.append('vector result;')\n    lines.append('')\n\n    for i in range(1, num_images):\n        lines.append(f'if (blend &lt; {i}.0) {{')\n        lines.append(f'    float t = blend - {i - 1}.0;')\n        lines.append(f'    result = lerp(map{i}, map{i + 1}, t);')\n        if i &lt; num_images - 1:\n            lines.append('} else ')\n        else:\n            lines.append('} else {')\n            lines.append(f'    result = map{num_images};')\n            lines.append('}')\n\n    lines.append('')\n    lines.append('@Cd = result;')\n    return \"\\n\".join(lines)\n</code></pre>"},{"location":"node_setup/node_helpers/#node_setup.node_helpers.clear_geo_cache","title":"<code>clear_geo_cache()</code>","text":"<p>Clears the cached geometry node. This is useful when the geometry node changes for a new input such as when comparing different date ranges or areas.</p> Source code in <code>src/node_setup/node_helpers.py</code> <pre><code>def clear_geo_cache():\n    \"\"\"\n    Clears the cached geometry node.\n    This is useful when the geometry node changes for a new input such as when comparing different date ranges or areas.\n    \"\"\"\n    global _cached_geo\n    _cached_geo = None\n</code></pre>"},{"location":"node_setup/node_helpers/#node_setup.node_helpers.ensure_blend_slider","title":"<code>ensure_blend_slider(wrangle_node, num_images)</code>","text":"<p>Ensures that the blend slider is present in the wrangle node since usually this requires user interaction on the wrangle node.   If it is not present, it creates a new slider with the specified number of images.</p> Source code in <code>src/node_setup/node_helpers.py</code> <pre><code>def ensure_blend_slider(wrangle_node, num_images):\n    \"\"\"\n    Ensures that the blend slider is present in the wrangle node since usually this requires user interaction on the wrangle node.    \n    If it is not present, it creates a new slider with the specified number of images.\n    \"\"\"\n    group = wrangle_node.parmTemplateGroup()\n    if not group.find(\"blendAll\"):\n        blend_slider = hou.FloatParmTemplate(\n            \"blendAll\", \"Blend All\", 1,\n            default_value=(0.0,),\n            min=0,\n            max=max(1.0, num_images - 1),\n            min_is_strict=True,\n            max_is_strict=True\n        )\n        group.append(blend_slider)\n        wrangle_node.setParmTemplateGroup(group)\n</code></pre>"},{"location":"node_setup/node_helpers/#node_setup.node_helpers.get_geo_node","title":"<code>get_geo_node()</code>","text":"<p>Gets the geometry node from the current context (only available in some cases) or usually prompts the user to select one. This function caches the geometry node to avoid prompting the user multiple times. If the geometry node is already selected, it will return the cached node.</p> Source code in <code>src/node_setup/node_helpers.py</code> <pre><code>def get_geo_node():\n    \"\"\"\n    Gets the geometry node from the current context (only available in some cases) or usually prompts the user to select one.\n    This function caches the geometry node to avoid prompting the user multiple times.\n    If the geometry node is already selected, it will return the cached node.\n    \"\"\"\n    global _cached_geo\n    # If already selected, return it\n    if _cached_geo is not None:\n        return _cached_geo\n\n    node = hou.pwd()\n    if node:\n        parent = node.parent()\n        if parent and parent.type().name() == \"geo\":\n            _cached_geo = parent\n            return _cached_geo\n\n    node_path = hou.ui.selectNode(\n        relative_to_node=None,\n        initial_node=None,\n        node_type_filter=hou.nodeTypeFilter.Sop,\n        title=\"Select a geometry node\"\n    )\n    if not node_path:\n        raise hou.NodeError(\"No geo node selected\")\n\n    geo_node = hou.node(node_path)\n    if not geo_node:\n        raise hou.NodeError(f\"Invalid node selected: {node_path}\")\n\n    _cached_geo = geo_node\n    return _cached_geo\n</code></pre>"},{"location":"node_setup/optical_nodes/","title":"Optical Data Nodes","text":""},{"location":"node_setup/optical_nodes/#node_setup.optical_nodes.OpticalNodeBuilder","title":"<code>OpticalNodeBuilder</code>","text":"<p>               Bases: <code>NodeBuilder</code></p> <p>OpticalNodeBuilder is a subclass of NodeBuilder that creates a node graph for optical data processing in Houdini. It sets up a series of nodes to handle optical satelite data, including blending image values and switching between textured and untextured terrain.</p> Source code in <code>src/node_setup/optical_nodes.py</code> <pre><code>class OpticalNodeBuilder(NodeBuilder):\n    \"\"\"\n    OpticalNodeBuilder is a subclass of NodeBuilder that creates a node graph for optical data processing in Houdini.\n    It sets up a series of nodes to handle optical satelite data, including blending image values and switching between textured and untextured terrain.\n    \"\"\"\n    def __init__(self, geo_node, data_folder, date_ranges):\n        \"\"\"\n        Initializes the OpticalNodeBuilder with a geometry node and data folder.\n\n        Args:\n            geo_node (hou.Node): The geometry node to build the node graph in.\n            data_folder (str): The folder where the optical data is stored.\n            date_ranges (list): A list of date ranges for the optical data.\n        \"\"\"\n        super().__init__(geo_node)\n        self.tiff = data_folder\n        self.date_ranges = date_ranges\n\n\n    def build(self):\n        \"\"\"\n        Builds the node graph for optical data processing.\n        This includes creating nodes for blending image values by passing in a VEX snippet, switching between textured and untextured terrain, and connecting the nodes to the existing terrain nodes.\n        It also sets colours on the nodes to better visualise the nodes the user should interact with, so green for the nodes that should be viewed and red for the nodes that should be interacted with.\n        \"\"\"\n        terrain_node = self.geo.node(\"OUT_Terrain\")\n        if terrain_node is None:\n            raise hou.NodeError(\"Node 'OUT_terrain' not found!\")\n\n        num_images = len(self.date_ranges)\n\n        snippet = build_wrangle_snippet(self.tiff, num_images, \"optical_data\", \"tiff\")\n\n        attrib_wrangle_optical = self.geo.createNode(\"attribwrangle\", \"blend_values\")\n        attrib_wrangle_optical.parm(\"snippet\").set(snippet)\n        attrib_wrangle_optical.setInput(0, terrain_node)\n        attrib_wrangle_optical.setDisplayFlag(True)\n        ensure_blend_slider(attrib_wrangle_optical, num_images)\n        attrib_wrangle_optical.setColor(hou.Color((1.0, 0.0, 0.0)))\n\n        color_node = self.geo.createNode(\"color\", \"untextured_terrain\")\n        color_node.parmTuple(\"color\").set((1,1,1))\n        color_node.setInput(0, terrain_node)\n\n        switch = self.geo.createNode(\"switch\", \"switch_untextured_to_textured_terrain\")\n        switch.setInput(0, attrib_wrangle_optical)\n        switch.setInput(1, color_node)\n        switch.setColor(hou.Color((1.0, 0.0, 0.0)))\n\n        # add attribute delete for uvs\n        attrib_delete = self.geo.createNode(\"attribdelete\", \"delete_uvs_terrain\")\n        attrib_delete.parm(\"ptdel\").set(\"uv\")\n        attrib_delete.setInput(0, switch)\n\n        out_terrain_thermal = self.geo.createNode(\"null\", \"OUT_Textured_Terrain\")\n        out_terrain_thermal.setInput(0, attrib_delete)\n        #out_terrain_thermal.setColor(hou.Color((1.0, 1.0, 1.0)))\n        out_terrain_thermal.setColor(hou.Color((.075, .30, .07550)))\n\n        out_terrain_thermal.setDisplayFlag(True)\n\n        self.geo.layoutChildren()\n</code></pre>"},{"location":"node_setup/optical_nodes/#node_setup.optical_nodes.OpticalNodeBuilder.__init__","title":"<code>__init__(geo_node, data_folder, date_ranges)</code>","text":"<p>Initializes the OpticalNodeBuilder with a geometry node and data folder.</p> <p>Parameters:</p> Name Type Description Default <code>geo_node</code> <code>Node</code> <p>The geometry node to build the node graph in.</p> required <code>data_folder</code> <code>str</code> <p>The folder where the optical data is stored.</p> required <code>date_ranges</code> <code>list</code> <p>A list of date ranges for the optical data.</p> required Source code in <code>src/node_setup/optical_nodes.py</code> <pre><code>def __init__(self, geo_node, data_folder, date_ranges):\n    \"\"\"\n    Initializes the OpticalNodeBuilder with a geometry node and data folder.\n\n    Args:\n        geo_node (hou.Node): The geometry node to build the node graph in.\n        data_folder (str): The folder where the optical data is stored.\n        date_ranges (list): A list of date ranges for the optical data.\n    \"\"\"\n    super().__init__(geo_node)\n    self.tiff = data_folder\n    self.date_ranges = date_ranges\n</code></pre>"},{"location":"node_setup/optical_nodes/#node_setup.optical_nodes.OpticalNodeBuilder.build","title":"<code>build()</code>","text":"<p>Builds the node graph for optical data processing. This includes creating nodes for blending image values by passing in a VEX snippet, switching between textured and untextured terrain, and connecting the nodes to the existing terrain nodes. It also sets colours on the nodes to better visualise the nodes the user should interact with, so green for the nodes that should be viewed and red for the nodes that should be interacted with.</p> Source code in <code>src/node_setup/optical_nodes.py</code> <pre><code>def build(self):\n    \"\"\"\n    Builds the node graph for optical data processing.\n    This includes creating nodes for blending image values by passing in a VEX snippet, switching between textured and untextured terrain, and connecting the nodes to the existing terrain nodes.\n    It also sets colours on the nodes to better visualise the nodes the user should interact with, so green for the nodes that should be viewed and red for the nodes that should be interacted with.\n    \"\"\"\n    terrain_node = self.geo.node(\"OUT_Terrain\")\n    if terrain_node is None:\n        raise hou.NodeError(\"Node 'OUT_terrain' not found!\")\n\n    num_images = len(self.date_ranges)\n\n    snippet = build_wrangle_snippet(self.tiff, num_images, \"optical_data\", \"tiff\")\n\n    attrib_wrangle_optical = self.geo.createNode(\"attribwrangle\", \"blend_values\")\n    attrib_wrangle_optical.parm(\"snippet\").set(snippet)\n    attrib_wrangle_optical.setInput(0, terrain_node)\n    attrib_wrangle_optical.setDisplayFlag(True)\n    ensure_blend_slider(attrib_wrangle_optical, num_images)\n    attrib_wrangle_optical.setColor(hou.Color((1.0, 0.0, 0.0)))\n\n    color_node = self.geo.createNode(\"color\", \"untextured_terrain\")\n    color_node.parmTuple(\"color\").set((1,1,1))\n    color_node.setInput(0, terrain_node)\n\n    switch = self.geo.createNode(\"switch\", \"switch_untextured_to_textured_terrain\")\n    switch.setInput(0, attrib_wrangle_optical)\n    switch.setInput(1, color_node)\n    switch.setColor(hou.Color((1.0, 0.0, 0.0)))\n\n    # add attribute delete for uvs\n    attrib_delete = self.geo.createNode(\"attribdelete\", \"delete_uvs_terrain\")\n    attrib_delete.parm(\"ptdel\").set(\"uv\")\n    attrib_delete.setInput(0, switch)\n\n    out_terrain_thermal = self.geo.createNode(\"null\", \"OUT_Textured_Terrain\")\n    out_terrain_thermal.setInput(0, attrib_delete)\n    #out_terrain_thermal.setColor(hou.Color((1.0, 1.0, 1.0)))\n    out_terrain_thermal.setColor(hou.Color((.075, .30, .07550)))\n\n    out_terrain_thermal.setDisplayFlag(True)\n\n    self.geo.layoutChildren()\n</code></pre>"},{"location":"node_setup/temperature_nodes/","title":"Temperature Data Nodes","text":""},{"location":"node_setup/temperature_nodes/#node_setup.temperature_nodes.TemperatureNodeBuilder","title":"<code>TemperatureNodeBuilder</code>","text":"<p>               Bases: <code>NodeBuilder</code></p> <p>TemperatureNodeBuilder is a subclass of NodeBuilder that creates a node graph for temperature data processing in Houdini. It sets up a series of nodes to handle temperature data, including blending image values, scattering points on the surface and visualising the temperatures with spheres.</p> Source code in <code>src/node_setup/temperature_nodes.py</code> <pre><code>class TemperatureNodeBuilder(NodeBuilder):\n    \"\"\"\n    TemperatureNodeBuilder is a subclass of NodeBuilder that creates a node graph for temperature data processing in Houdini.\n    It sets up a series of nodes to handle temperature data, including blending image values, scattering points on the surface and visualising the temperatures with spheres.\n    \"\"\"\n    def __init__(self, geo_node, data_folder, date_ranges):\n        \"\"\"\n        Initializes the TemperatureNodeBuilder with a geometry node and data folder.\n\n        Args:\n            geo_node (hou.Node): The geometry node to build the node graph in.\n            data_folder (str): The folder where the temperature data is stored.\n            date_ranges (list): A list of date ranges for the temperature data.\n        \"\"\"\n        super().__init__(geo_node)\n        self.png = data_folder\n        self.date_ranges = date_ranges\n\n    def build(self):\n        \"\"\"\n        Builds the node graph for temperature data processing.\n        This includes creating nodes for blending image values by passing in a VEX snippet, scattering points on the surface, visualising the temperatures and connecting the nodes to the existing terrain and optical nodes.\n        It also sets colours on the nodes to better visualise the nodes the user should interact with, so green for the nodes that should be viewed and red for the nodes that should be interacted with.\n        \"\"\"\n        num_images = len(self.date_ranges)\n\n        snippet = build_wrangle_snippet(self.png, num_images, \"thermal_data\", \"png\")\n\n        terrain_node = self.geo.node(\"OUT_Terrain\")\n        if terrain_node is None:\n            raise hou.NodeError(\"Node 'OUT_terrain' not found.\")\n\n        attrib_wrangle_temperature = self.geo.createNode(\"attribwrangle\", \"blend_values_temperature\")\n        attrib_wrangle_temperature.parm(\"snippet\").set(snippet)\n        attrib_wrangle_temperature.setInput(0, terrain_node)\n        attrib_wrangle_temperature.setDisplayFlag(True)\n        ensure_blend_slider(attrib_wrangle_temperature, num_images)\n        # attrib_wrangle_temperature.setColor(hou.Color((1.0, 0.0, 0.0)))\n        attrib_wrangle_temperature.parm(\"blendAll\").setExpression('ch(\"../blend_values/blendAll\")')\n\n\n        scatter = self.geo.createNode(\"scatter\", \"scatter_points\")\n        scatter.parm(\"npts\").set(2000)\n        scatter.setInput(0, attrib_wrangle_temperature)\n\n        sphere_size_wrangle = self.geo.createNode(\"attribwrangle\", \"sphere_scale\")\n        sphere_size_wrangle.parm(\"snippet\").set('f@pscale = clamp(@Cd.r * 100.0, 0.1, 3.0);')  \n        sphere_size_wrangle.setInput(0, scatter)\n\n        sphere = self.geo.createNode(\"sphere\", \"sphere_temperature\")\n        sphere.parm(\"type\").set(0) \n        sphere.parm(\"radx\").set(0.5)\n        sphere.parm(\"rady\").set(0.5)\n        sphere.parm(\"radz\").set(0.5)\n        sphere.parm(\"scale\").set(0.2)\n\n        transform = self.geo.createNode(\"xform\", \"sphere_transform\")\n        transform.parm(\"ty\").set(0.1)\n        transform.setInput(0, sphere)\n\n        transform_sphere_size = self.geo.createNode(\"xform\", \"sphere_size\")\n        transform_sphere_size.setColor(hou.Color((1.0, 0.0, 0.0)))  # Red\n        transform_sphere_size.setInput(0, transform)\n\n        copy = self.geo.createNode(\"copytopoints::2.0\", \"copy_spheres\")\n        copy.setInput(0, transform_sphere_size)\n        copy.setInput(1, sphere_size_wrangle)\n        copy.setColor(hou.Color((1.0, 1.0, 1.0)))\n\n\n        attrib_delete = self.geo.createNode(\"attribdelete\", \"delete_uvs_spheres\")\n        attrib_delete.parm(\"ptdel\").set(\"uv\")\n        attrib_delete.setInput(0, copy)\n\n        color_node = self.geo.createNode(\"color\", \"spheres_color\")\n        color_node.parmTuple(\"color\").set((0.15,0.3,0.3))\n        color_node.setInput(0, attrib_delete)\n        color_node.setColor(hou.Color((1.0, 0.0, 0.0)))  # Red\n\n        thermal_out = self.geo.createNode(\"null\", \"OUT_THERMAL\")\n        thermal_out.setInput(0, color_node)\n        thermal_out.setColor(hou.Color((1.0, 1.0, 1.0)))\n\n        terrain_textured_out = self.geo.node(\"OUT_Textured_Terrain\")\n        if terrain_textured_out is None:\n            raise hou.NodeError(\"Node 'OUT_Textured_Terrain' not found.\")\n\n        merge = self.geo.createNode(\"merge\", \"merge_terrain_thermal\")\n        merge.setInput(0, thermal_out)\n        merge.setInput(1, terrain_textured_out)\n\n        out_terrain_thermal = self.geo.createNode(\"null\", \"OUT_Temperature_Change_with_Terrain\")\n        out_terrain_thermal.setInput(0, merge)\n        out_terrain_thermal.setColor(hou.Color((.075, .30, .0750)))\n\n        self.geo.layoutChildren()\n\n        out_terrain_thermal.setDisplayFlag(True)\n        out_terrain_thermal.setRenderFlag(True)\n</code></pre>"},{"location":"node_setup/temperature_nodes/#node_setup.temperature_nodes.TemperatureNodeBuilder.__init__","title":"<code>__init__(geo_node, data_folder, date_ranges)</code>","text":"<p>Initializes the TemperatureNodeBuilder with a geometry node and data folder.</p> <p>Parameters:</p> Name Type Description Default <code>geo_node</code> <code>Node</code> <p>The geometry node to build the node graph in.</p> required <code>data_folder</code> <code>str</code> <p>The folder where the temperature data is stored.</p> required <code>date_ranges</code> <code>list</code> <p>A list of date ranges for the temperature data.</p> required Source code in <code>src/node_setup/temperature_nodes.py</code> <pre><code>def __init__(self, geo_node, data_folder, date_ranges):\n    \"\"\"\n    Initializes the TemperatureNodeBuilder with a geometry node and data folder.\n\n    Args:\n        geo_node (hou.Node): The geometry node to build the node graph in.\n        data_folder (str): The folder where the temperature data is stored.\n        date_ranges (list): A list of date ranges for the temperature data.\n    \"\"\"\n    super().__init__(geo_node)\n    self.png = data_folder\n    self.date_ranges = date_ranges\n</code></pre>"},{"location":"node_setup/temperature_nodes/#node_setup.temperature_nodes.TemperatureNodeBuilder.build","title":"<code>build()</code>","text":"<p>Builds the node graph for temperature data processing. This includes creating nodes for blending image values by passing in a VEX snippet, scattering points on the surface, visualising the temperatures and connecting the nodes to the existing terrain and optical nodes. It also sets colours on the nodes to better visualise the nodes the user should interact with, so green for the nodes that should be viewed and red for the nodes that should be interacted with.</p> Source code in <code>src/node_setup/temperature_nodes.py</code> <pre><code>def build(self):\n    \"\"\"\n    Builds the node graph for temperature data processing.\n    This includes creating nodes for blending image values by passing in a VEX snippet, scattering points on the surface, visualising the temperatures and connecting the nodes to the existing terrain and optical nodes.\n    It also sets colours on the nodes to better visualise the nodes the user should interact with, so green for the nodes that should be viewed and red for the nodes that should be interacted with.\n    \"\"\"\n    num_images = len(self.date_ranges)\n\n    snippet = build_wrangle_snippet(self.png, num_images, \"thermal_data\", \"png\")\n\n    terrain_node = self.geo.node(\"OUT_Terrain\")\n    if terrain_node is None:\n        raise hou.NodeError(\"Node 'OUT_terrain' not found.\")\n\n    attrib_wrangle_temperature = self.geo.createNode(\"attribwrangle\", \"blend_values_temperature\")\n    attrib_wrangle_temperature.parm(\"snippet\").set(snippet)\n    attrib_wrangle_temperature.setInput(0, terrain_node)\n    attrib_wrangle_temperature.setDisplayFlag(True)\n    ensure_blend_slider(attrib_wrangle_temperature, num_images)\n    # attrib_wrangle_temperature.setColor(hou.Color((1.0, 0.0, 0.0)))\n    attrib_wrangle_temperature.parm(\"blendAll\").setExpression('ch(\"../blend_values/blendAll\")')\n\n\n    scatter = self.geo.createNode(\"scatter\", \"scatter_points\")\n    scatter.parm(\"npts\").set(2000)\n    scatter.setInput(0, attrib_wrangle_temperature)\n\n    sphere_size_wrangle = self.geo.createNode(\"attribwrangle\", \"sphere_scale\")\n    sphere_size_wrangle.parm(\"snippet\").set('f@pscale = clamp(@Cd.r * 100.0, 0.1, 3.0);')  \n    sphere_size_wrangle.setInput(0, scatter)\n\n    sphere = self.geo.createNode(\"sphere\", \"sphere_temperature\")\n    sphere.parm(\"type\").set(0) \n    sphere.parm(\"radx\").set(0.5)\n    sphere.parm(\"rady\").set(0.5)\n    sphere.parm(\"radz\").set(0.5)\n    sphere.parm(\"scale\").set(0.2)\n\n    transform = self.geo.createNode(\"xform\", \"sphere_transform\")\n    transform.parm(\"ty\").set(0.1)\n    transform.setInput(0, sphere)\n\n    transform_sphere_size = self.geo.createNode(\"xform\", \"sphere_size\")\n    transform_sphere_size.setColor(hou.Color((1.0, 0.0, 0.0)))  # Red\n    transform_sphere_size.setInput(0, transform)\n\n    copy = self.geo.createNode(\"copytopoints::2.0\", \"copy_spheres\")\n    copy.setInput(0, transform_sphere_size)\n    copy.setInput(1, sphere_size_wrangle)\n    copy.setColor(hou.Color((1.0, 1.0, 1.0)))\n\n\n    attrib_delete = self.geo.createNode(\"attribdelete\", \"delete_uvs_spheres\")\n    attrib_delete.parm(\"ptdel\").set(\"uv\")\n    attrib_delete.setInput(0, copy)\n\n    color_node = self.geo.createNode(\"color\", \"spheres_color\")\n    color_node.parmTuple(\"color\").set((0.15,0.3,0.3))\n    color_node.setInput(0, attrib_delete)\n    color_node.setColor(hou.Color((1.0, 0.0, 0.0)))  # Red\n\n    thermal_out = self.geo.createNode(\"null\", \"OUT_THERMAL\")\n    thermal_out.setInput(0, color_node)\n    thermal_out.setColor(hou.Color((1.0, 1.0, 1.0)))\n\n    terrain_textured_out = self.geo.node(\"OUT_Textured_Terrain\")\n    if terrain_textured_out is None:\n        raise hou.NodeError(\"Node 'OUT_Textured_Terrain' not found.\")\n\n    merge = self.geo.createNode(\"merge\", \"merge_terrain_thermal\")\n    merge.setInput(0, thermal_out)\n    merge.setInput(1, terrain_textured_out)\n\n    out_terrain_thermal = self.geo.createNode(\"null\", \"OUT_Temperature_Change_with_Terrain\")\n    out_terrain_thermal.setInput(0, merge)\n    out_terrain_thermal.setColor(hou.Color((.075, .30, .0750)))\n\n    self.geo.layoutChildren()\n\n    out_terrain_thermal.setDisplayFlag(True)\n    out_terrain_thermal.setRenderFlag(True)\n</code></pre>"},{"location":"node_setup/terrain_nodes/","title":"Terrain Data Nodes","text":""},{"location":"node_setup/terrain_nodes/#node_setup.terrain_nodes.DEMNodeBuilder","title":"<code>DEMNodeBuilder</code>","text":"<p>               Bases: <code>NodeBuilder</code></p> <p>DEMNodeBuilder is a subclass of NodeBuilder that creates a node graph for Digital Elevation Model (DEM) data in Houdini. It sets up a series of nodes to handle DEM data, including reading the TIFF file, scaling the heightfield, converting it to polygons, and setting up the DEM output node.</p> Source code in <code>src/node_setup/terrain_nodes.py</code> <pre><code>class DEMNodeBuilder(NodeBuilder):\n    \"\"\"\n    DEMNodeBuilder is a subclass of NodeBuilder that creates a node graph for Digital Elevation Model (DEM) data in Houdini.\n    It sets up a series of nodes to handle DEM data, including reading the TIFF file, scaling the heightfield, converting it to polygons, and setting up the DEM output node.\n    \"\"\"\n    def __init__(self, geo_node, tiff_path, coord_json):\n        \"\"\"\n        Initializes the DEMNodeBuilder with a geometry node, TIFF file path, and coordinate JSON file.\n\n        Args:\n            geo_node (hou.Node): The geometry node to build the node graph in.\n            tiff_path (str): The path to the TIFF file containing the DEM data.\n            coord_json (str): The path to the JSON file containing coordinate information.\n        \"\"\"\n        super().__init__(geo_node)\n        self.tiff = tiff_path\n        self.coord_json = coord_json\n\n    def build(self):\n        \"\"\"\n        Builds the node graph for DEM data processing.\n        This includes creating nodes for reading the TIFF file, scaling the heightfield, converting it to polygons, and setting up the output node.        \"\"\"\n\n        hf = self.geo.createNode(\"heightfield_file\", \"DEM_in\")\n        hf.parm(\"filename\").set(self.tiff)\n        hf.parm('size').set(100) # set this dynamically later\n        hf.parm('heightscale').set(2200/1000)\n        hf.setColor(hou.Color((1.0, 1.0, 1.0)))\n\n        bbox = get_bbox_from_json(self.coord_json)\n        bbox_to_km_scale(bbox)\n        sx, sz = calculate_transform_scale_from_coords(self.coord_json, bbox)\n\n        xf = self.geo.createNode(\"xform\", \"scale_km\")\n        xf.setInput(0, hf)\n        xf.parm(\"sx\").set(sz) # needs to be swapped for houdini axes\n        xf.parm(\"sz\").set(sx)\n\n        # create heightfield convert\n        hf_convert = self.geo.createNode(\"convertheightfield\", \"convert_to_polygons\")\n        hf_convert.setInput(0, xf)\n        hf_convert.parm(\"lod\").set(0.5)  # Convert to heightfield\n\n        out = self.geo.createNode(\"null\", \"OUT_Terrain\")\n        out.setInput(0, hf_convert)\n        out.setColor(hou.Color((1.0, 1.0, 1.0)))\n\n        out.setDisplayFlag(True)\n        self.layout()\n</code></pre>"},{"location":"node_setup/terrain_nodes/#node_setup.terrain_nodes.DEMNodeBuilder.__init__","title":"<code>__init__(geo_node, tiff_path, coord_json)</code>","text":"<p>Initializes the DEMNodeBuilder with a geometry node, TIFF file path, and coordinate JSON file.</p> <p>Parameters:</p> Name Type Description Default <code>geo_node</code> <code>Node</code> <p>The geometry node to build the node graph in.</p> required <code>tiff_path</code> <code>str</code> <p>The path to the TIFF file containing the DEM data.</p> required <code>coord_json</code> <code>str</code> <p>The path to the JSON file containing coordinate information.</p> required Source code in <code>src/node_setup/terrain_nodes.py</code> <pre><code>def __init__(self, geo_node, tiff_path, coord_json):\n    \"\"\"\n    Initializes the DEMNodeBuilder with a geometry node, TIFF file path, and coordinate JSON file.\n\n    Args:\n        geo_node (hou.Node): The geometry node to build the node graph in.\n        tiff_path (str): The path to the TIFF file containing the DEM data.\n        coord_json (str): The path to the JSON file containing coordinate information.\n    \"\"\"\n    super().__init__(geo_node)\n    self.tiff = tiff_path\n    self.coord_json = coord_json\n</code></pre>"},{"location":"node_setup/terrain_nodes/#node_setup.terrain_nodes.DEMNodeBuilder.build","title":"<code>build()</code>","text":"<p>Builds the node graph for DEM data processing. This includes creating nodes for reading the TIFF file, scaling the heightfield, converting it to polygons, and setting up the output node.</p> Source code in <code>src/node_setup/terrain_nodes.py</code> <pre><code>def build(self):\n    \"\"\"\n    Builds the node graph for DEM data processing.\n    This includes creating nodes for reading the TIFF file, scaling the heightfield, converting it to polygons, and setting up the output node.        \"\"\"\n\n    hf = self.geo.createNode(\"heightfield_file\", \"DEM_in\")\n    hf.parm(\"filename\").set(self.tiff)\n    hf.parm('size').set(100) # set this dynamically later\n    hf.parm('heightscale').set(2200/1000)\n    hf.setColor(hou.Color((1.0, 1.0, 1.0)))\n\n    bbox = get_bbox_from_json(self.coord_json)\n    bbox_to_km_scale(bbox)\n    sx, sz = calculate_transform_scale_from_coords(self.coord_json, bbox)\n\n    xf = self.geo.createNode(\"xform\", \"scale_km\")\n    xf.setInput(0, hf)\n    xf.parm(\"sx\").set(sz) # needs to be swapped for houdini axes\n    xf.parm(\"sz\").set(sx)\n\n    # create heightfield convert\n    hf_convert = self.geo.createNode(\"convertheightfield\", \"convert_to_polygons\")\n    hf_convert.setInput(0, xf)\n    hf_convert.parm(\"lod\").set(0.5)  # Convert to heightfield\n\n    out = self.geo.createNode(\"null\", \"OUT_Terrain\")\n    out.setInput(0, hf_convert)\n    out.setColor(hou.Color((1.0, 1.0, 1.0)))\n\n    out.setDisplayFlag(True)\n    self.layout()\n</code></pre>"},{"location":"node_setup/terrain_nodes/#node_setup.terrain_nodes.FallbackNodeBuilder","title":"<code>FallbackNodeBuilder</code>","text":"<p>               Bases: <code>NodeBuilder</code></p> <p>FallbackNodeBuilder is a subclass of NodeBuilder that creates a fallback node graph in Houdini. It sets up a series of nodes to handle cases where the DEM data is not available or invalid. It creates a blank TIFF file and sets up a File SOP pointing to the fallback TIFF and colours it red to make it obvisou to the user that it is a fallback.</p> Source code in <code>src/node_setup/terrain_nodes.py</code> <pre><code>class FallbackNodeBuilder(NodeBuilder):\n    \"\"\"\n    FallbackNodeBuilder is a subclass of NodeBuilder that creates a fallback node graph in Houdini.\n    It sets up a series of nodes to handle cases where the DEM data is not available or invalid.\n    It creates a blank TIFF file and sets up a File SOP pointing to the fallback TIFF and colours it red to make it obvisou to the user that it is a fallback.\n    \"\"\"\n    def __init__(self, geo_node, fallback_path, width, height):\n        \"\"\"\n        Initializes the FallbackNodeBuilder with a geometry node, fallback TIFF file path, width and height.\n\n        Args:\n            geo_node (hou.Node): The geometry node to build the node graph in.\n            fallback_path (str): The path to the fallback TIFF file.\n            width (float): The width of the blank TIFF image.\n            height (float): The height of the blank TIFF image.\n        \"\"\"\n        super().__init__(geo_node)\n        self.fallback_path = fallback_path\n        self.width = width\n        self.height = height\n\n    def create_blank_tiff(self):\n        \"\"\"Creates a blank 16-bit grayscale TIFF file.\"\"\"\n        data = np.zeros((self.height, self.width), dtype=np.uint16)\n        image = Image.fromarray(data, mode='I;16')\n        image.save(self.fallback_path, format='TIFF')\n        print(f\"Blank TIFF image created at: {self.fallback_path}\")\n\n    def build(self):\n        \"\"\"Creates a File SOP pointing to the fallback TIFF and colours it red.\"\"\"\n        self.create_blank_tiff()\n        file_node = self.geo.createNode(\"file\", \"fallback_file_class\")\n        file_node.parm(\"file\").set(self.fallback_path)\n\n        # set colour to red\n        colour_node = self.geo.createNode(\"color\", \"color_fallback\")\n        colour_node.parm('colorr').set(1)\n        colour_node.parm('colorg').set(0)\n        colour_node.parm('colorb').set(0)\n        colour_node.setInput(0, file_node)\n\n        null_node = self.geo.createNode(\"null\", \"OUT_terrain\")\n        null_node.setInput(0, colour_node)\n        null_node.setDisplayFlag(True)\n\n        self.layout()\n        print(\"Fallback null node added successfully!\")\n        return null_node\n</code></pre>"},{"location":"node_setup/terrain_nodes/#node_setup.terrain_nodes.FallbackNodeBuilder.__init__","title":"<code>__init__(geo_node, fallback_path, width, height)</code>","text":"<p>Initializes the FallbackNodeBuilder with a geometry node, fallback TIFF file path, width and height.</p> <p>Parameters:</p> Name Type Description Default <code>geo_node</code> <code>Node</code> <p>The geometry node to build the node graph in.</p> required <code>fallback_path</code> <code>str</code> <p>The path to the fallback TIFF file.</p> required <code>width</code> <code>float</code> <p>The width of the blank TIFF image.</p> required <code>height</code> <code>float</code> <p>The height of the blank TIFF image.</p> required Source code in <code>src/node_setup/terrain_nodes.py</code> <pre><code>def __init__(self, geo_node, fallback_path, width, height):\n    \"\"\"\n    Initializes the FallbackNodeBuilder with a geometry node, fallback TIFF file path, width and height.\n\n    Args:\n        geo_node (hou.Node): The geometry node to build the node graph in.\n        fallback_path (str): The path to the fallback TIFF file.\n        width (float): The width of the blank TIFF image.\n        height (float): The height of the blank TIFF image.\n    \"\"\"\n    super().__init__(geo_node)\n    self.fallback_path = fallback_path\n    self.width = width\n    self.height = height\n</code></pre>"},{"location":"node_setup/terrain_nodes/#node_setup.terrain_nodes.FallbackNodeBuilder.build","title":"<code>build()</code>","text":"<p>Creates a File SOP pointing to the fallback TIFF and colours it red.</p> Source code in <code>src/node_setup/terrain_nodes.py</code> <pre><code>def build(self):\n    \"\"\"Creates a File SOP pointing to the fallback TIFF and colours it red.\"\"\"\n    self.create_blank_tiff()\n    file_node = self.geo.createNode(\"file\", \"fallback_file_class\")\n    file_node.parm(\"file\").set(self.fallback_path)\n\n    # set colour to red\n    colour_node = self.geo.createNode(\"color\", \"color_fallback\")\n    colour_node.parm('colorr').set(1)\n    colour_node.parm('colorg').set(0)\n    colour_node.parm('colorb').set(0)\n    colour_node.setInput(0, file_node)\n\n    null_node = self.geo.createNode(\"null\", \"OUT_terrain\")\n    null_node.setInput(0, colour_node)\n    null_node.setDisplayFlag(True)\n\n    self.layout()\n    print(\"Fallback null node added successfully!\")\n    return null_node\n</code></pre>"},{"location":"node_setup/terrain_nodes/#node_setup.terrain_nodes.FallbackNodeBuilder.create_blank_tiff","title":"<code>create_blank_tiff()</code>","text":"<p>Creates a blank 16-bit grayscale TIFF file.</p> Source code in <code>src/node_setup/terrain_nodes.py</code> <pre><code>def create_blank_tiff(self):\n    \"\"\"Creates a blank 16-bit grayscale TIFF file.\"\"\"\n    data = np.zeros((self.height, self.width), dtype=np.uint16)\n    image = Image.fromarray(data, mode='I;16')\n    image.save(self.fallback_path, format='TIFF')\n    print(f\"Blank TIFF image created at: {self.fallback_path}\")\n</code></pre>"},{"location":"utils/auth/","title":"Authentification","text":""},{"location":"utils/auth/#utils.auth.fetch_auth_token","title":"<code>fetch_auth_token(client_id, client_secret)</code>","text":"<p>Fetches an authentication token from the Copernicus API using client credentials.</p> <p>Parameters:</p> Name Type Description Default <code>client_id</code> <code>str</code> <p>The client ID for authentication.</p> required <code>client_secret</code> <code>str</code> <p>The client secret for authentication.</p> required <p>Returns:</p> Name Type Description <code>token</code> <code>str</code> <p>The access token if successful, None otherwise.</p> Source code in <code>src/utils/auth.py</code> <pre><code>def fetch_auth_token(client_id, client_secret):\n    \"\"\"\n    Fetches an authentication token from the Copernicus API using client credentials.\n\n    Args:\n        client_id (str): The client ID for authentication.\n        client_secret (str): The client secret for authentication.\n\n    Returns:\n        token (str): The access token if successful, None otherwise.\n    \"\"\"\n    auth_url = \"https://identity.dataspace.copernicus.eu/auth/realms/CDSE/protocol/openid-connect/token\"\n    auth_data = {\n        \"grant_type\": \"client_credentials\",\n        \"client_id\": client_id,\n        \"client_secret\": client_secret\n    }\n\n    # send http post request to auth_url with credentials\n    response = requests.post(auth_url, data=auth_data)\n\n    if response.status_code == 200: # 200 here means success, token received\n        token = response.json().get(\"access_token\") \n        return token\n    else:\n        print(\"error fetching token\")\n        return None\n</code></pre>"},{"location":"utils/bbox/","title":"BBox","text":""},{"location":"utils/bbox/#utils.bbox.bbox_to_km_scale","title":"<code>bbox_to_km_scale(bbox)</code>","text":"<p>Converts bounding box coordinates to kilometers.</p> <p>Parameters:</p> Name Type Description Default <code>bbox</code> <code>list</code> <p>List of bounding box coordinates [min_lon, min_lat, max_lon, max_lat].</p> required <p>Returns:</p> Name Type Description <code>tuple</code> <code>tuple[float, float]</code> <p>Width and height in kilometers.</p> Source code in <code>src/utils/bbox.py</code> <pre><code>def bbox_to_km_scale(bbox) -&gt; tuple[float, float]:\n    \"\"\"\n    Converts bounding box coordinates to kilometers.\n\n    Args:\n        bbox (list): List of bounding box coordinates [min_lon, min_lat, max_lon, max_lat].\n\n    Returns:\n        tuple: Width and height in kilometers.\n        \"\"\"\n    min_lon, min_lat, max_lon, max_lat = bbox\n\n    # Constants\n    lat_km = 111  # 1 degree latitude \u2248 111 km\n    avg_lat = (min_lat + max_lat) / 2  # Average latitude for better accuracy\n    lon_km = 111 * math.cos(math.radians(avg_lat))  # 1 degree longitude in km\n\n    # Compute distances in km but scaled down\n    width_km = abs((max_lon - min_lon) * lon_km * 0.01)\n    height_km = abs((max_lat - min_lat) * lat_km * 0.01)  \n\n    #print(f\"Width: {width_km} km, Height: {height_km} km\")\n    return width_km, height_km\n</code></pre>"},{"location":"utils/bbox/#utils.bbox.calculate_transform_scale_from_coords","title":"<code>calculate_transform_scale_from_coords(file_path, bbox)</code>","text":"<p>Calculate the scale factors for transforming coordinates based on pixel dimensions and bounding box coordinates. This is then used in the terrain nodes set up for the scale of the heightfield.</p> <p>Parameters:</p> Name Type Description Default <code>file_path</code> <code>str</code> <p>Path to the file containing pixel dimensions, so to the data folder of the DEM tiff image.</p> required <code>bbox</code> <code>list</code> <p>List of bounding box coordinates [min_lon, min_lat, max_lon, max_lat]. </p> required <p>Returns:</p> Name Type Description <code>tuple</code> <code>tuple[float, float]</code> <p>A pair of scale factors (scale_x, scale_z).</p> Source code in <code>src/utils/bbox.py</code> <pre><code>def calculate_transform_scale_from_coords(file_path, bbox) -&gt; tuple[float, float]:\n    \"\"\"\n    Calculate the scale factors for transforming coordinates based on pixel dimensions and bounding box coordinates.\n    This is then used in the terrain nodes set up for the scale of the heightfield.\n\n    Args:\n        file_path (str): Path to the file containing pixel dimensions, so to the data folder of the DEM tiff image.\n        bbox (list): List of bounding box coordinates [min_lon, min_lat, max_lon, max_lat]. \n\n    Returns:\n        tuple: A pair of scale factors (scale_x, scale_z).\n    \"\"\"\n\n    dimensions = calculate_pixel_dimensions_from_file(file_path)\n\n    if not dimensions:\n        print(\"Failed to get pixel dimensions.\")\n        return None\n\n    width_px, height_px = dimensions\n    lon_min, lat_min, lon_max, lat_max = bbox\n\n    lat_km = 111\n    avg_lat = (lat_min + lat_max) / 2\n    lon_km = 111 * math.cos(math.radians(avg_lat))\n\n    real_width_km = (lon_max - lon_min) * lon_km\n    real_height_km = (lat_max - lat_min) * lat_km\n\n    # based on houdini output: 1 Houdini unit = 16.62 pixels, since 100 units = 1662 px\n    # so we need to scale it by 16.62\n    scale_x = (real_width_km / width_px) *16.62\n    scale_z = (real_height_km / height_px) *16.62\n\n    return scale_x, scale_z\n</code></pre>"},{"location":"utils/bbox/#utils.bbox.get_bbox_from_json","title":"<code>get_bbox_from_json(file_path)</code>","text":"<p>Reads bounding box coordinates from a JSON file.</p> <p>Parameters:</p> Name Type Description Default <code>file_path</code> <code>str</code> <p>Path to the JSON file.</p> required <p>Returns:</p> Type Description <code>list[float]</code> <p>Bounding Box coordinates as a list [lon_min, lat_min, lon_max, lat_max].</p> Source code in <code>src/utils/bbox.py</code> <pre><code>def get_bbox_from_json(file_path: str) -&gt; list[float]:\n    \"\"\"\n    Reads bounding box coordinates from a JSON file.\n\n    Args:\n        file_path (str): Path to the JSON file.\n\n    Returns:\n        Bounding Box coordinates as a list [lon_min, lat_min, lon_max, lat_max].\n    \"\"\"\n    with open(file_path, 'r', encoding='utf-8') as f:\n        data = json.load(f)\n\n    required_keys = [\"lon_min\", \"lat_min\", \"lon_max\", \"lat_max\"]\n    if not all(key in data for key in required_keys):\n        raise KeyError(f\"JSON must contain keys: {', '.join(required_keys)}\")\n\n    bbox = [data[key] for key in required_keys]\n    if not all(isinstance(val, (int, float)) for val in bbox):\n        raise TypeError(\"All bounding box values must be numeric.\")\n\n    return bbox\n</code></pre>"},{"location":"utils/date_ranges/","title":"Date Ranges","text":""},{"location":"utils/date_ranges/#utils.date_ranges.get_date_ranges","title":"<code>get_date_ranges(start_qdate, end_qdate, freq_text)</code>","text":"<p>Generate date ranges based on start and end QDate objects and frequency.</p> <p>Parameters:</p> Name Type Description Default <code>start_qdate</code> <code>QDate</code> <p>Start date.</p> required <code>end_qdate</code> <code>QDate</code> <p>End date.</p> required <code>freq_text</code> <code>str</code> <p>Frequency type, either \"weekly\" or \"monthly\".</p> required <p>Returns:</p> Name Type Description <code>ranges</code> <code>list</code> <p>List of tuples with ISO formatted date ranges.</p> Source code in <code>src/utils/date_ranges.py</code> <pre><code>def get_date_ranges(start_qdate, end_qdate, freq_text):\n    \"\"\"\n    Generate date ranges based on start and end QDate objects and frequency.\n\n    Args:\n        start_qdate (QDate): Start date.\n        end_qdate (QDate): End date.\n        freq_text (str): Frequency type, either \"weekly\" or \"monthly\".\n\n    Returns:\n        ranges (list): List of tuples with ISO formatted date ranges.\n    \"\"\"\n    # convert and clamp\n    start = date(start_qdate.year(), start_qdate.month(), start_qdate.day())\n    end   = date(end_qdate.year(),   end_qdate.month(),   end_qdate.day())\n\n    def clamp28(d):\n        return date(d.year, d.month, min(d.day, 28))\n\n    start, end = clamp28(start), clamp28(end)\n\n    # formatting utility\n    def iso_range(d0, d1):\n        return (\n            datetime.combine(d0, time.min).strftime(\"%Y-%m-%dT%H:%M:%SZ\"),\n            datetime.combine(d1, time.max).strftime(\"%Y-%m-%dT%H:%M:%SZ\")\n        )\n\n    # iterate months\n    def month_iter(d1, d2):\n        y1, m1 = d1.year, d1.month\n        y2, m2 = d2.year, d2.month\n        y, m = y1, m1\n        while (y, m) &lt;= (y2, m2):\n            yield y, m\n            m += 1\n            if m &gt; 12:\n                m, y = 1, y + 1\n\n    ranges = []\n    if freq_text.lower() == \"weekly\":\n        segments = [(1,7), (8,14), (15,21), (22,28)]\n        for yr, mth in month_iter(start, end):\n            for ds, de in segments:\n                seg_start = date(yr, mth, ds)\n                seg_end   = date(yr, mth, de)\n                if seg_end &lt; start or seg_start &gt; end:\n                    continue\n                # _always_ give the full week slice\n                ranges.append(iso_range(seg_start, seg_end))\n\n    elif freq_text.lower() == \"monthly\":\n        for yr, mth in month_iter(start, end):\n            seg_start = date(yr, mth, 1)\n            seg_end   = date(yr, mth, 28)\n            if seg_end &lt; start or seg_start &gt; end:\n                continue\n            ranges.append(iso_range(seg_start, seg_end))\n\n    else:\n        raise ValueError(\"freq_text must be 'weekly' or 'monthly'\")\n\n    return ranges\n</code></pre>"},{"location":"utils/delete_images/","title":"Delete Images","text":""},{"location":"utils/delete_images/#utils.delete_images.delete_existing_images","title":"<code>delete_existing_images(folder_path, prefix, format)</code>","text":"<p>Deletes images in the specified folder that match the given prefix/file name and format.</p> <p>Parameters:</p> Name Type Description Default <code>folder_path</code> <code>str</code> <p>The path to the folder containing images.</p> required <code>prefix</code> <code>str</code> <p>The prefix/file name of the images to delete.</p> required <code>format</code> <code>str</code> <p>The file format of the images to delete.</p> required Source code in <code>src/utils/delete_images.py</code> <pre><code>def delete_existing_images(folder_path, prefix, format):\n    \"\"\"\n    Deletes images in the specified folder that match the given prefix/file name and format.\n\n    Args:\n        folder_path (str): The path to the folder containing images.\n        prefix (str): The prefix/file name of the images to delete.\n        format (str): The file format of the images to delete.\n    \"\"\"\n\n    folder = Path(folder_path)\n    pattern = f\"{prefix}_*.{format}\"\n    images = list(folder.glob(pattern))\n\n    if not images:\n        print(f\"No {format} images matching '{pattern}' found in {folder_path}.\")\n        return\n\n    for image in images:\n        try:\n            image.unlink()\n            print(f\"Deleted: {image}\")\n        except Exception as e:\n            print(f\"Failed to delete {image}: {e}\")\n</code></pre>"},{"location":"utils/grid_size/","title":"Grid Size","text":""},{"location":"utils/grid_size/#utils.grid_size.calculate_pixel_dimensions_from_file","title":"<code>calculate_pixel_dimensions_from_file(file_path, resolution=0.0003)</code>","text":"<p>Calculate the pixel dimensions of an image based on geographical coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>file_path</code> <code>str</code> <p>Path to the JSON file containing coordinates.</p> required <code>resolution</code> <code>float</code> <p>The resolution, same as in the data download.</p> <code>0.0003</code> <p>Returns:</p> Name Type Description <code>Width</code> <code>int</code> <p>Width of the image in pixels.</p> <code>Height</code> <code>int</code> <p>Height of the image in pixels.</p> Source code in <code>src/utils/grid_size.py</code> <pre><code>def calculate_pixel_dimensions_from_file(file_path, resolution=0.0003):\n    \"\"\"\n    Calculate the pixel dimensions of an image based on geographical coordinates.\n\n    Args:\n        file_path (str): Path to the JSON file containing coordinates.\n        resolution (float): The resolution, same as in the data download.\n\n    Returns:\n        Width (int): Width of the image in pixels.\n        Height (int): Height of the image in pixels.\n    \"\"\"\n\n    try:\n        with open(file_path, 'r') as f:\n            coords = json.load(f)\n\n        lat_range = coords['lat_max'] - coords['lat_min']\n        lon_range = coords['lon_max'] - coords['lon_min']\n\n        width_pixels = round(lon_range / resolution)\n        height_pixels = round(lat_range / resolution)\n\n        return width_pixels, height_pixels\n\n    except (json.JSONDecodeError, KeyError, FileNotFoundError) as e:\n        print(f\"Error: {e}\")\n        return None\n</code></pre>"},{"location":"utils/grid_size/#utils.grid_size.get_image_dimensions","title":"<code>get_image_dimensions(file_path)</code>","text":"<p>Get the pixel dimensions of an image based on its geographical coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>file_path</code> <code>str</code> <p>Path to the JSON file containing coordinates.</p> required <p>Returns:</p> Name Type Description <code>Width</code> <code>int</code> <p>Width of the image in pixels.</p> <code>Height</code> <code>int</code> <p>Height of the image in pixels.</p> Source code in <code>src/utils/grid_size.py</code> <pre><code>def get_image_dimensions(file_path):\n    \"\"\"\n    Get the pixel dimensions of an image based on its geographical coordinates.\n\n    Args:\n        file_path (str): Path to the JSON file containing coordinates.\n\n    Returns:\n        Width (int): Width of the image in pixels.\n        Height (int): Height of the image in pixels.\n    \"\"\"\n    width, height = calculate_pixel_dimensions_from_file(file_path)\n    # print(f\"Image dimensions: {width} x {height}\")\n    return width, height\n</code></pre>"},{"location":"utils/open_flask_server/","title":"Open Flask Server","text":""},{"location":"utils/open_flask_server/#utils.open_flask_server.kill_old_server","title":"<code>kill_old_server()</code>","text":"<p>Kill any existing Flask server process.</p> Source code in <code>src/utils/open_flask_server.py</code> <pre><code>def kill_old_server():\n    \"\"\"Kill any existing Flask server process.\"\"\"\n    try:\n        pid = int(PID_FILE.read_text().strip())\n        if psutil.pid_exists(pid):\n            os.kill(pid, signal.SIGTERM)\n            time.sleep(1)\n    except Exception:\n        pass\n    PID_FILE.unlink(missing_ok=True)\n</code></pre>"},{"location":"utils/open_flask_server/#utils.open_flask_server.start_new_server","title":"<code>start_new_server(data_folder)</code>","text":"<p>Start server pointing to the user-selected data folder, folder is needed for saving the coorinates later on.</p> <p>Parameters:</p> Name Type Description Default <code>data_folder</code> <code>str</code> <p>Path to the data folder.</p> required Source code in <code>src/utils/open_flask_server.py</code> <pre><code>def start_new_server(data_folder: str):\n    \"\"\"\n    Start server pointing to the user-selected data folder, folder is needed for saving the coorinates later on.\n\n    Args:\n        data_folder (str): Path to the data folder.\n    \"\"\"\n    kill_old_server()\n    print(f\"Starting Flask server with data folder: {data_folder}\")\n    proc = subprocess.Popen([sys.executable, str(SERVER_SCRIPT), data_folder], preexec_fn=os.setsid)\n    PID_FILE.write_text(str(proc.pid))\n</code></pre>"},{"location":"utils/open_map/","title":"Open Map","text":""},{"location":"utils/open_map/#utils.open_map.open_map","title":"<code>open_map()</code>","text":"<p>Open the map.html file in Firefox. This function checks if the file exists and opens it using the specified browser.</p> Source code in <code>src/utils/open_map.py</code> <pre><code>def open_map():\n    \"\"\"\n    Open the map.html file in Firefox.\n    This function checks if the file exists and opens it using the specified browser.\n    \"\"\"\n    map_file = Path(__file__).parent / \"map.html\"\n    firefox_path = \"/usr/bin/firefox\"\n\n    if not map_file.is_file():\n        print(f\"Error: The file {map_file} does not exist.\")\n        return\n\n    subprocess.Popen([firefox_path, str(map_file)])\n</code></pre>"},{"location":"utils/post_json/","title":"Post JSON","text":""},{"location":"utils/post_json/#utils.post_json.post_json","title":"<code>post_json(url, headers, json_data)</code>","text":"<p>Post JSON data to a specified URL with headers.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>The URL to post the data to.</p> required <code>headers</code> <code>dict</code> <p>The headers to include in the request.</p> required <code>json_data</code> <code>dict</code> <p>The JSON data to post.</p> required <p>Returns:</p> Type Description <p>Response object or None if the request failed.</p> Source code in <code>src/utils/post_json.py</code> <pre><code>def post_json(url, headers, json_data):\n    \"\"\"\n    Post JSON data to a specified URL with headers.\n\n    Args:\n        url (str): The URL to post the data to.\n        headers (dict): The headers to include in the request.\n        json_data (dict): The JSON data to post.\n\n    Returns:\n        Response object or None if the request failed.\n    \"\"\"\n    try:\n        response = requests.post(url, headers=headers, json=json_data)\n        response.raise_for_status()\n        return response\n    except requests.RequestException as e:\n        print(f\"HTTP POST failed: {e}\")\n        return None\n</code></pre>"},{"location":"utils/server/","title":"Server","text":""},{"location":"utils/server/#utils.server.create_app","title":"<code>create_app(data_folder)</code>","text":"<p>Create and configure the Flask app.</p> <p>Parameters:</p> Name Type Description Default <code>data_folder</code> <code>str</code> <p>Path to the data folder.</p> required <p>Returns:</p> Type Description <p>Flask app: Configured Flask application.</p> Source code in <code>src/utils/server.py</code> <pre><code>def create_app(data_folder):\n    \"\"\"\n    Create and configure the Flask app.\n\n    Args:\n        data_folder (str): Path to the data folder.\n\n    Returns:\n        Flask app: Configured Flask application.\n    \"\"\"\n    Path(data_folder).mkdir(parents=True, exist_ok=True)\n\n    app = Flask(__name__)\n    app.config['DATA_FOLDER'] = data_folder\n\n    @app.route('/')\n    def index():\n        return \"Flask is running\"\n\n    @app.route('/save-coords', methods=['POST', 'OPTIONS'])\n    def save_coords():\n        if request.method == 'OPTIONS':\n            response = jsonify({'status': 'ok'})\n            response.headers.add(\"Access-Control-Allow-Origin\", \"*\")\n            response.headers.add(\"Access-Control-Allow-Headers\", \"*\")\n            response.headers.add(\"Access-Control-Allow-Methods\", \"POST, OPTIONS\")\n            return response\n\n        data = request.get_json(force=True)\n\n        save_path = Path(app.config['DATA_FOLDER']) / \"coords.json\"\n        print(\"Saving coords to:\", save_path)\n\n        with open(save_path, 'w') as f:\n            json.dump(data, f, indent=2)\n\n        response = jsonify({\n            \"status\": \"success\",\n            \"message\": \"Coordinates saved!\",\n            \"path\": str(save_path)\n        })\n        response.headers.add(\"Access-Control-Allow-Origin\", \"*\")\n        return response\n\n    return app\n</code></pre>"}]}